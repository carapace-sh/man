# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: split
description: split a file into pieces
flags:
    --additional-suffix=: append an additional SUFFIX to file names
    --filter=: write to shell COMMAND; file name is $FILE
    --help: display this help and exit
    --hex-suffixes=: same as -x, but allow setting the start value
    --numeric-suffixes=: same as -d, but allow setting the start value
    --verbose: print a diagnostic just before each
    --version: output version information and exit
    -C, --line-bytes=: put at most SIZE bytes of records per output file
    -a, --suffix-length=: generate suffixes of length N (default 2)
    -b, --bytes=: put SIZE bytes per output file
    -d: use numeric suffixes starting at 0, not alphabetic
    -e, --elide-empty-files: do not generate empty output files with '-n'
    -l, --lines=: put NUMBER lines/records per output file
    -n, --number=: generate CHUNKS output files; see explanation below
    -t, --separator=: use SEP instead of newline as the record separator;
    -u, --unbuffered: immediately copy input to output with '-n r/...'
    -x: use hex suffixes starting at 0, not alphabetic
documentation:
    command: |-
        [AI] The `split` command in Unix-based systems is used to split a single file into multiple files based on a specified delimiter (character, whitespace, or regular expression). The basic syntax is:

        ```bash
        split <file> <delimiter> <output_prefix>
        ```

        For example, given a file `input.txt` containing lines of text separated by newlines, you could split it into files named `xaa`, `xab`, etc., each containing one line from the original file with the following command:

        ```bash
        split input.txt \n x
        ```

        The `\n` represents a newline character as the delimiter, and `x` is the prefix for the output files.
    flag:
        additional-suffix: '[AI] The `git split` command is used to create a new branch from a commit in another branch, making it easier to work on a specific feature or fix. The `--additional-suffix` option modifies the name of the new branches created by adding a suffix to them. For example, if you use `--additional-suffix=v1`, Git will create a new branch named `<existing_branch>v1` instead of just `<new_branch>`. This can be useful for keeping your development and release branches organized.'
        bytes: '[AI] The `split` command in Unix-based systems is used to split a large file into smaller parts, called output files. The option `--bytes` specifies that the input file should be split at fixed byte size boundaries. This means that each output file will contain data up to a specified number of bytes (specified by the user), and a new output file will be created when that size is reached in the input file. For example, using `split --bytes=10M filename` would create several files named `xaa`, `xab`, `xac`, and so on, each containing data up to 10 megabytes from the original file.'
        d: |-
            [AI] The `split` command with the option `-d` in Unix or Linux is used to split a large file into smaller pieces based on a fixed number of characters, bytes or records instead of lines (which is the default behavior). This can be useful when dealing with binary files or specific data formats.

            For instance, if you have a large text file and want to split it into parts of 10MB each, you would use:
            ```bash
            split -d --bytes=10M inputFile output_
            ```
            This will create multiple files named `output_aa`, `output_ab`, `output_ac` ... Each file will contain approximately 10MB of data from the original file. The `-d` option is used to avoid adding sequence numbers (like 'aa', 'ab' etc.) in the output filenames. Instead, it simply appends an alphabet for each split part.
        elide-empty-files: '[AI] The `split` command in Unix or Linux is used to split a large file into smaller pieces or files based on a specified size or number of lines. The option `--elide-empty-lines` is used with this command to suppress the creation of output files that are empty, i.e., contain no data. When this option is set, if any line splitting results in an empty file, it will be omitted and its content will be appended to the previous file instead. This can help reduce the number of output files generated by the `split` command, making it easier to manage and process the resulting files.'
        filter: |-
            [AI] The `split` command in Unix-based systems is used to split a line or file based on a specific delimiter into multiple lines or files. The `--filter` option is an argument provided with `split` that applies a command to each output file created.

            For instance, given a large text file `largefile.txt`, one could use:

            ```bash
            split --additional-information=%03i --filter='sed -e "s/pattern/replacement/" %f' largefile.txt output_
            ```

            This command splits `largefile.txt` into smaller files named `output_001`, `output_002`, etc., and applies the `sed` command to replace all occurrences of "pattern" with "replacement" in each file before creating it. Thus, the result will be a set of smaller files where every instance of "pattern" has been replaced by "replacement".
        help: '[AI] The `split` command in Unix-based systems is used to split large files into smaller pieces. The option `--help` is used to display detailed information about how to use the `split` command, including the correct syntax, available options, and examples. It provides a concise and clear explanation of each option''s purpose and usage, making it easier for users to utilize the `split` command effectively.'
        hex-suffixes: '[AI] `split` is a command-line utility in Unix and Unix-like operating systems used for splitting and merging files. The option `--hex-suffixes` modifies the behavior of the `split` command when it splits a file into multiple parts. With this option, each output file will have a suffix representing the hexadecimal representation of its piece number. For example, if you split a file named `input` into 10MB chunks and use this option, the output files will be named `xaa`, `xab`, `xac`, ..., `xaj`. This naming convention can be useful when dealing with large binary files or specific use cases where the hexadecimal suffixes provide additional meaning.'
        line-bytes: '[AI] The `split` command in Unix/Linux with the option `--line-bytes=<number>` splits a file into lines where each line has exactly `<number>` bytes, rather than by the default newline character (which usually signifies the end of a line). This can be useful when dealing with files that do not conform to the standard newline format, such as binary files or data streams.'
        lines: '[AI] The `split` command in Unix-based systems is used to split a large file into smaller parts based on a specified delimiter (by default, after each line). The `--lines` option is used with `split` to specify that the output files should be created as individual files for each line. For example, `split --lines=10 input.txt output_%03d` would split the file `input.txt` into 10-line long files named `output_001`, `output_002`, ..., `output_099`.'
        number: |-
            [AI] The `split` command in Unix-based systems is used to split a file into multiple parts based on a delimiter such as a character or a regular expression. The `--number` option is an argument that specifies how many output files will be created. For instance, if you have a large text file and want to create 10 smaller files, each containing data up to the 10th occurrence of a certain delimiter, you would use the following command:

            ```bash
            split --number=10 <filename> <output_prefix>
            ```

            Here, `<filename>` is the name of your input file and `<output_prefix>` is the desired prefix for your output files. The flag `--number=10` tells the `split` command to create 10 output files. Each file will contain data up to the 10th occurrence of the delimiter, with the suffixes `xaa`, `xab`, ..., `xaj` (where x is the prefix and j is a number from 0 to 9) being appended to the base filename for each output file.
        numeric-suffixes: '[AI] `split` is a command in Unix and Unix-like operating systems used to split a file into multiple parts based on a delimiter. The option `--numeric-suffixes` modifies the behavior of this command. When this option is used, each output file created by `split` will be named with a sequence number suffix starting from 0. For example, if you use the command `split --numeric-suffixes myfile`, it will create files like `xaa`, `xab`, `xac`, and so on. This can be useful when dealing with large files that need to be processed in parts, where each part is easily identifiable by its name.'
        separator: |-
            [AI] The `split` command in Unix-based systems is used to split a given input stream into lines or other types of fields based on a specified separator. The `--separator` option specifies the character or regular expression that is used as the separator for splitting the input.

            For example, if you have a text file with comma-separated values and you want to split it into separate columns based on commas, you can use the following command:

            ```bash
            split --add=4 --delimiter=, --lines=5 filename
            ```

            This will split the `filename` into five parts, each containing up to 20 lines (the default), with the lines within each part being separated by commas. The `--add=4` option adds empty output files after the last file to make sure that all data is processed.
        suffix-length: '[AI] The `split` command in Unix is used to split a single file into multiple files based on a delimiter or regular expression. The option `--suffix-length=NUM` specifies that each output file should have a suffix of length NUM characters. For example, using `--suffix-length=2` would create output files with extensions such as ".tx.0", ".tx.1" and so on. This can be useful when processing large files where keeping track of the individual parts is important.'
        unbuffered: '[AI] The `split` command in Unix-based systems is used to split a file into multiple parts based on a specified delimiter (by default, a newline character). The option `--unbuffered` is used with the `split` command to process input files without buffering. This means that data is read and processed line by line immediately as it is being read from the input file, rather than reading the entire file into memory before processing. It can be useful when dealing with large files or limited resources.'
        verbose: '[AI] `split` is a command-line utility in Unix and Unix-like operating systems used to split large files into smaller pieces. The option `--verbose` is used with this command to display detailed information about the splitting process, including the number of the input file being processed, the output file name, and the size of each output file. So, when you use `split --verbose filename outputprefix`, it will split the given file `filename` into multiple files named `outputprefixaa`, `outputprefixab`, etc., and print detailed information for each step in the terminal.'
        version: '[AI] `split --version` is a command used in Unix-based operating systems to check the version of the `split` utility installed in the system. When you type this command in the terminal, it returns the version number and other relevant information such as the release date and compilation details of the `split` utility. This information helps users ensure they have the latest or desired version of the tool for their tasks, or troubleshoot potential compatibility issues.'
        x: '[AI] The `split` command in Unix-like operating systems is used to split a large file into smaller parts, each of a fixed size. The option `-x` is used to specify that the output files should have a length equal to the specified size in characters instead of the default of bytes. For example, `split -x 10 myfile output_%03d` will split `myfile` into parts `output_001`, `output_002`, ..., each containing up to 10 characters.'
