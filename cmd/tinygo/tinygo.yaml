# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: tinygo
description: TinyGo is a Go compiler for small places
flags:
    -cpuprofile=: cpuprofile output
    -dumpssa: dump internal Go SSA
    -gc=: garbage collector to use
    -ldflags=: Go link tool compatible ldflags
    -llvm-features=: comma separated LLVM features to enable
    -no-debug: strip debug information
    -o=: output
    -ocd-commands=: OpenOCD commands, overriding target spec
    -ocd-output: print OCD daemon output during debug
    -opt=: optimization level
    -panic=: panic strategy
    -port=: flash port
    -print-allocs=: regular expression of functions for which heap allocations should be printed
    -print-stacks: print stack sizes of goroutines
    -printir: print LLVM IR
    -programmer=: which hardware programmer to use
    -scheduler=: which scheduler to use
    -serial=: which serial output to use
    -size=: print sizes
    -tags=: a space-separated list of extra build tags
    -target=: chip/board name or JSON target specification file
    -verifyir: run extra verification steps on LLVM IR
    -wasm-abi=: WebAssembly ABI conventions
    -x: Print commands
documentation:
    command: '[AI] TinyGo is a static compiler for the Go programming language that produces small, fast, and efficient binaries. It''s designed to create standalone applications with minimal runtime and memory footprint, making it ideal for resource-constrained devices or microcontrollers. TinyGo uses a subset of Go features and provides additional tools to optimize code size and performance.'
    flag:
        cpuprofile: '[AI] `tinygo -cpuprofile` is a command-line option for the TinyGo (golang.org/x/tinygo) compiler. It generates CPU profiles during program execution. The resulting profile files contain detailed information about the program''s runtime behavior, including the amount of time spent in each function and system call. These profiles can be used for performance analysis and optimization by providing insights into hotspots and inefficient code parts.'
        dumpssa: '[AI] `tinygo -dssa` is a command-line option for TinyGO, a Go compiler for constrained environments. This flag generates static Single Assignment form (SSA) of the compiled Go code. In software development, SSA form ensures that each variable is assigned only once in a single basic block and has no side effects. The output of this command is a SSA-form Intermediate Representation (IR) file that can be further processed for various purposes such as optimization or analysis tools.'
        gc: '[AI] `-gc` is a flag used in TinyGo, a Go compiler for small devices and constrained environments. This flag enables the Garbage Collector (GC) in the compiled program. The GC automatically manages memory allocation and deallocation, freeing up memory that is no longer being used by the program. Without `-gc`, TinyGo generates programs with static memory management, which can be useful for systems with limited resources where manual memory management is necessary.'
        ldflags: '[AI] `-ldflags` is a build flag used in TinyGo (a Go compiler for small devices). It allows passing linker flags to the linker during compilation, which can be used to set various options such as defining symbols, specifying external libraries, or optimizing the linking process. For example, `-ldflags ''-L. -lmylibrary` would tell TinyGo to include the "mylibrary" library located in the current directory during linking.'
        llvm-features: |-
            [AI] `tinygo` is a Go compiler for constrained environments, such as microcontrollers and other systems with limited resources. The `-llvm-features` flag is an option that can be passed to `tinygo` when building Go projects for these environments.

            This flag enables additional LLVM optimizations and features, which can help improve the size and performance of the generated code for the target platform. Specifically, it activates certain LLVM passes and features designed for low-resource systems, such as loop unrolling, function inlining, constant propagation, dead code elimination, and others.

            Using `-llvm-features` can lead to smaller binary sizes and faster execution times, making it an essential flag when working with resource-constrained environments using TinyGo. However, it's important to note that some of these optimizations may not be applicable or effective for all Go projects, depending on their specific use cases and requirements.
        no-debug: '[AI] `tinygo` is a Go compiler for creating small, standalone binaries. The option `-no-debug` is used to disable the inclusion of debug information in the compiled binary. This results in smaller binary size and faster execution as debug information is not needed at runtime. It also makes the binary less readable for reverse engineering purposes.'
        o: '[AI] The `-o` flag in TinyGo is used to specify the output file name when building a Go project with TinyGo, which is a Go compiler optimized for small devices and constrained environments. The syntax is `tinygo build -o output.ext source.go`, where `output.ext` is the desired name and extension of the output binary or object file.'
        ocd-commands: '[AI] `tinygo -ocd-commands` is a command used with TinyGo, an open-source Go compiler for embedded systems. This option generates a set of commands to program an on-chip debugger or JTAG interface using OpenOCD (Open On-Chip Debugger). The output is a file containing specific OpenOCD instructions for initializing, programming, and debugging the microcontroller via the given interface. It''s crucial in embedded development workflows where hardware debugging and flashing are essential steps before deploying the application.'
        ocd-output: '[AI] The `-ocd-output` flag in TinyGo is used to specify the output format for the Open On-Chip Debugger (OCD) files during the compilation of firmware for microcontrollers. These OCD files enable debugging and communication between the compiler, the hardware debugger, and the target device using a JTAG or SWD interface. The flag accepts a file path where the generated OCD files will be saved. For instance, `-ocd-output=my_debugger.gdbinit` saves the OCD files in the format required by the `gdbinit` debugger configuration file.'
        opt: '[AI] `-opt` is a command-line flag used with TinyGo, an open-source Go compiler for small devices and constraint environments. This flag enables advanced optimization options to reduce code size and improve performance. The exact optimizations applied depend on the specific option strings provided along with `-opt`. For instance, `-opt name=go:linkname` may be used to optimize symbol names for better linking efficiency. `-opt name=gc` activates garbage collector optimizations, and so on. Users can consult TinyGo''s documentation or experiment to determine which optimization flags best suit their use case.'
        panic: '[AI] The `-panic` flag in TinyGo is used to control how the Go compiler (gc) handles panics during program execution. When set, the compiler enables the production of panic-recording data, which can be useful for debugging and understanding the cause of a panic. This information includes the call stack at the point of the panic and any associated data. Without this flag, the Go runtime would simply terminate the program upon encountering a panic.'
        port: '[AI] `-port` is a command-line option for TinyGo, a Go compiler for resource-constrained devices. It specifies the port number to use for the built program''s listening socket when deploying network applications. By default, no port is set and the program will not start a server. Using `-port` followed by an integer value, such as `-port 8080`, sets that port for the server to listen on.'
        print-allocs: '[AI] `tinygo -print-allocs` is a command-line option for the TinyGo compiler. It enables allocator tracing, which means that TinyGo will print out detailed information about each memory allocation and deallocation during the execution of the compiled Go program. This can be useful for memory debugging and profiling to understand the memory usage patterns of the application.'
        print-stacks: '[AI] `tinygo print-stacks` is a command provided by TinyGO, a Go compiler for microcontrollers and constrained environments. It generates stack usage reports for each Go function in the compiled binary. These reports include the maximum and current stack depths, allowing developers to optimize their code and ensure it fits within memory constraints of target devices.'
        printir: '[AI] `tinygo -printir` is a command-line option for TinyGo, a Go compiler designed for microcontrollers and other resource-constrained devices. This flag generates an Intermediate Representation (IR) output file instead of the usual binary or object file. IR is a low-level representation of the source code that can be further processed or analyzed by other tools without generating machine code. The IR file includes more details about the program''s structure and dependencies, which may be useful for debugging, optimization, or reverse engineering purposes.'
        programmer: '[AI] The "tinygo-programmer" flag in TinyGo is used to build and compile Go programs for microcontrollers using TinyGo, a Go compiler optimized for resource-constrained devices. This flag enables features like small code size, reduced memory footprint, and efficient use of hardware resources. It also activates certain optimizations during the build process specific to microcontroller development.'
        scheduler: |-
            [AI] The `-scheduler` flag in TinyGo (Golang's lightweight constraint variant) is used to specify the scheduling policy for the Go runtime on single-core or resource-constrained systems. It can be set to one of three modes:

            1. **Round Robin**: This mode schedules goroutines in a first-come, first-served order. Each goroutine gets an equal amount of CPU time before being preempted and the next goroutine is executed.
            2. **Priority**: In this mode, each goroutine can be assigned a priority level. Higher priority goroutines get more CPU time than lower priority ones, leading to better control over system resources for critical tasks.
            3. **FIFO (First In, First Out)**: Similar to Round Robin, but instead of equal time slices, this mode schedules goroutines based on their arrival order in the runqueue. This is useful for systems where predictable response times are more important than CPU utilization.

            By default, TinyGo uses the Round Robin scheduler. You can use the `-scheduler` flag to explicitly set the scheduling policy when invoking the TinyGo compiler. For example:
            ```bash
            tinygo build -scheduler=priority -priorities="{M: 2, H: 1}" main.go
            ```
            This command sets the scheduler to priority mode and assigns a higher priority (M) to goroutine 'main' and a lower priority (H) to other goroutines.
        serial: '[AI] "tinygo-serial" is a compile target for TinyGo (Golang for constrained environments), which generates a serial-enabled Go binary. The flag configures the toolchain to include the necessary serial communication package and linker scripts, enabling the program to send and receive data over a serial connection. This makes it suitable for developing IoT projects or other applications that require low-level device interaction through serial communication.'
        size: '[AI] `-size` is a flag used in TinyGo, a static compiler for the Go programming language. This flag is used to set a limit on the size of the generated binary or executable file. By default, TinyGo generates binaries that are optimized for size and memory usage, but `-size` allows specifying an exact maximum size in bytes or kilobytes (K), megabytes (MB), or even gigabytes (GB). The goal is to create extremely compact binaries suitable for resource-constrained environments.'
        tags: '[AI] `-tags` is a build tag in TinyGo, a Go compiler for microcontrollers. It allows specifying multiple tags to selectively build and include specific packages or components in the project. The flags take the format `-tags=tag1,tag2`, where each tag represents a distinct set of dependencies and configurations. This can be useful for building different variants of the same project, such as versions with different features, targeting various hardware platforms, or optimized for different performance profiles.'
        target: '[AI] `-target` is a command-line option for TinyGo, an open-source Go compiler for microcontrollers and other constrained environments. It specifies the target architecture or platform for the generated binary. For example, `-target=arm` produces a binary for ARM architecture, while `-target=wasm` generates WebAssembly code. This option lets TinyGo generate optimized binaries tailored to specific hardware or software targets.'
        verifyir: '[AI] `tinygo verifyir` is a command in the TinyGo compiler suite used for verifying imported Go (`.go`) files referenced by the main Go file during compilation. The `-verifyir` flag instructs TinyGo to perform an additional check on these imported packages, ensuring they have no compile errors before proceeding with the build process of the main application. This helps maintain a clean and error-free codebase by identifying any issues early in the development cycle.'
        wasm-abi: '[AI] `tinygo -wasm-abi` is a command-line option used with TinyGo, a static compiler for Go. It specifies the WebAssembly System Interface (WASI) ABI (Application Binary Interface) to be used when building a Go program for deployment as a WebAssembly module. The chosen ABI defines how functions and data are named and passed between the WebAssembly module and its host environment, ensuring interoperability.'
        x: '[AI] `-x` is a build flag in TinyGo (a Go compiler for small devices and hosts). It tells the compiler to link the output executable with all dependencies statically, making it self-contained without requiring external libraries during runtime.'
