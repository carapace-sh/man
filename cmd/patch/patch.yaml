# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: patch
description: appy a diff file to an original
flags:
    --backup-if-mismatch: Back up if the patch does not match exactly.
    --binary: Read and write data in binary mode.
    --dry-run: Do not actually change any files; just print what would happen.
    --help: Output this help.
    --merge: Merge using conflict markers instead of creating reject files.
    --no-backup-if-mismatch: Back up mismatches only if otherwise requested.
    --posix: Conform to the POSIX standard.
    --quiet: Work silently unless an error occurs.
    --quoting-style=: output file names using quoting style WORD.
    --read-only=: How to handle read-only input files
    --reject-format=: Create 'context' or 'unified' rejects.
    --verbose: Output extra information about the work being done.
    -B, --prefix=: Prepend PREFIX to backup file names.
    -D, --ifdef=: Make merged if-then-else output using NAME.
    -E, --remove-empty-files: Remove output files that are empty after patching.
    -F, --fuzz=: Set the fuzz factor to LINES for inexact matching.
    -N, --forward: Ignore patches that appear to be reversed or already applied.
    -R, --reverse: Assume patches were created with old and new files swapped.
    -T, --set-time: Likewise, assuming local time.
    -V, --version-control=: Use STYLE version control.
    -Y, --basename-prefix=: Prepend PREFIX to backup file basenames.
    -Z, --set-utc: Set times of patched files, assuming diff uses UTC (GMT).
    -b, --backup: Back up the original contents of each file.
    -c, --context: Interpret the patch as a context difference.
    -d, --directory=: Change the working directory to DIR first.
    -e, --ed: Interpret the patch as an ed script.
    -f, --force: Like -t, but ignore bad-Prereq patches, and assume unreversed.
    -g, --get=: Get files from RCS etc. if positive; ask if negative.
    -i, --input=: Read patch from PATCHFILE instead of stdin.
    -l, --ignore-whitespace: Ignore white space changes between patch and input.
    -n, --normal: Interpret the patch as a normal difference.
    -o, --output=: Output patched files to FILE.
    -p, --strip=: Strip NUM leading components from file names.
    -r, --reject-file=: Output rejects to FILE.
    -s, --silent: Work silently unless an error occurs.
    -t, --batch: Ask no questions; skip bad-Prereq patches; assume reversed.
    -u, --unified: Interpret the patch as a unified difference.
    -v, --version: Output version info.
    -z, --suffix=: Append SUFFIX to backup file names.
documentation:
    command: '[AI] The `patch` command is a utility used for applying difference files, also known as patches. It compares two versions of a file and generates a patch file containing the differences between them. This patch file can then be applied to update or modify the original file. The `patch` command itself can both apply and create these patches, making it a convenient tool for managing file revisions in a text-based manner.'
    flag:
        backup: '[AI] `git patch --backup` is a Git command used to apply a patch file, while creating a backup of the original files before applying it. This is useful when making experimental changes or applying patches from an external source, as it allows you to revert back to the original state if something goes wrong. The backup files will be saved in the `./patches/` subdirectory of your Git working directory with a `.orig` extension added to their names.'
        backup-if-mismatch: '[AI] The `--backup-if-mismatch` option in Git''s `patch` command creates a backup file when applying a patch if the contents of the files being patched have differences that aren''t resolved during the application process. This is useful for preserving the original state of files before overwriting them with the changes from the patch, especially when applying patches manually or resolving merge conflicts. The backups are saved with a `.orig` extension in the same directory as the patched file.'
        basename-prefix: '[AI] `git patch --basename-prefix` is a Git command used to apply a series of patches with a common prefix in their filenames. The option `--basename-prefix` specifies the common prefix string, allowing you to easily apply multiple patches having the same base name but different suffixes in one go. For instance, if you have three patches named `01-myfeature.patch`, `02-myfeature-more.patch`, and `03-myfeature-final.patch`, you can apply them together with `git patch --basename "01-myfeature" < patch1.txt patch2.txt patch3.txt`.'
        batch: '[AI] `git patch --batch` is a Git command used to apply a series of patches stored in a file or given on the command line. The `--batch` option specifies that the patches are provided in batch format, which means each patch contains only the difference between two revisions without any context header or footer information. This command is typically used when applying a large number of patches manually or semi-automatically, as it allows for easier scripting and automation of the patch application process.'
        binary: '[AI] The `--binary` option in Git''s `patch` command is used to apply a binary file patch instead of a text-based diff patch. It takes one argument, which is the path to the binary patch file. When this option is used, Git will attempt to apply the binary data directly to the specified file(s) without attempting to generate or display any textual diff information. This can be useful when working with binary files that do not have a well-defined textual representation of changes between versions.'
        context: '[AI] `git patch --context` is a command used in Git for generating and applying text-based patches. The `--context` option sets the number of lines of context to be included in each patch file. This means that when you generate a patch using this option, Git will include the specified number of lines before and after each changed line in the patch file. By default, Git uses 3 lines of context, but you can change this number by providing an argument to `--context`. For example, `git format-patches --10 -- file.txt` will generate a patch with 10 lines of context for each changed line in `file.txt`. This option is useful when working with larger code changes or when reviewing patches to ensure that the correct lines have been modified.'
        directory: '[AI] The `--directory` option is used with the Git command `git patch`. It specifies that the given patch file contains a series of changes, each affecting a separate directory under the top level of the project. When applying this patch using `git apply`, the changes will be applied to those directories recursively.'
        dry-run: '[AI] `patch --dry-run` is a command used in Unix-based systems for applying a patch file to a file, simulating the changes without actually making them. It''s an optional safety measure to check what changes will be applied before executing them permanently. The output of this command shows which lines would be modified or added if the patch were to be applied in the real world.'
        ed: '[AI] The `--ed` option is a scripting mode in Git''s `patch` command. In this mode, instead of applying a diff file as-is, the patch command allows you to manually edit the hunks (sections) of the diff before committing them for application. This way, you can make fine adjustments to the changes before they are permanently committed in your repository. It''s particularly useful when dealing with complex or intricate changes that may require more control and customization over the patching process.'
        force: '[AI] The `--force` flag in Git is used to override user warnings and force an operation to continue, even if it might result in loss of data or other unwanted consequences. When you use this option with commands like `git checkout`, `git reset`, or `git push`, Git will not perform any confirmation prompts before carrying out the specified action, potentially overwriting changes that have been made since the last commit. It''s essential to exercise caution when using this flag and ensure you understand the risks involved.'
        forward: '[AI] `git patch --forward` is a Git command used to apply a series of patches in the forward direction, meaning from the current branch to a new or different branch. It''s typically used for cherry-picking commits or applying patches from a remote repository into your local work. This command keeps the commit history intact and creates new commits with the applied changes in the target branch.'
        fuzz: '[AI] `--fuzz` is an option used with the `git patch` command in version control systems like Git. It''s used for applying patches with potentially incorrect or malicious changes to test the robustness of your codebase against various kinds of fuzz, which can help identify vulnerabilities. The flag runs the patch application multiple times with different input data to observe how the system reacts. The goal is to improve the codebase resilience against unexpected or adversarial inputs.'
        get: '[AI] `git patch --get` is a Git command used to apply a stored, unapplied patch from the index or the refspec to the current working directory or a named branch. The applied changes will be displayed in the console as diff output without making any permanent commits. This command can be useful for reviewing changes before deciding whether to apply them permanently with `git apply` or `git cherry-pick`.'
        help: '[AI] The `--help` option when used with Git''s `patch` command displays detailed help information about the command, including a list of available sub-commands and their usage. It provides information on how to apply, create, or reverse patches using Git''s patch tool.'
        ifdef: '[AI] The `--ifdef` option in the `patch` command is used to apply patches only if certain conditions are met in the file being patched. It works by checking if a defined macro exists in the file before applying the patch. If the macro is not found, then the patch is not applied. This can be useful when working with large codebases and wanting to selectively apply patches based on specific conditions. The syntax for using `--ifdef` is as follows: `patch < patchfile.diff --ifdef=MACRO [< file]` where `MACRO` is the name of the macro to check for.'
        ignore-whitespace: '[AI] The `--ignore-whitespace` option in Git''s `patch` command is used to apply a patch file even if there are differences in whitespace between the files being patched and the current version in the repository. By default, `git apply` will not apply patches with whitespace differences due to formatting issues, but this flag overrides that behavior and applies the patch regardless. This can be useful when dealing with patches where the whitespace formatting is not important or when working on projects with developers who have different preferred coding styles.'
        input: '[AI] The `--input` option in Git''s `patch` command specifies the file containing the difference between two revisions or branches to be applied using the patch command. It takes a single argument, which is the path to the input file. For example, `git apply --input my_patch.diff` would apply the changes described in the `my_patch.diff` file.'
        merge: '[AI] `git patch --merge` is a command used in Git version control system for applying a series of changes represented by a patch file to the current working directory or a specific branch. The `--merge` option tells Git to perform a three-way merge of the changes from the patch with the current local branches and the remote-tracking branch, resulting in a new commit. This command is commonly used to apply patches that have been received via email or other external sources into your Git repository.'
        no-backup-if-mismatch: '[AI] The `--no-backup-if-mismatch` flag is used with Git''s `patch` command for merging changes. With this option, Git will not create a backup file when there are merge conflicts. Instead, it will overwrite the existing files with the changes from both branches without creating any backups of the previous versions. This can be useful if you prefer to resolve conflicts manually and don''t want Git to keep track of every version during the merging process.'
        normal: '[AI] `git patch --normal` is a command used in Git to apply a patch file without creating a commit. The `--normal` option tells Git that you want to apply the changes as if you had manually edited the files and staged them for a commit, but without actually creating a new commit. This can be useful when you want to test how a patch would affect your working directory without committing the changes. If the patch applies cleanly, the files will be updated in place; if there are conflicts, Git will pause and allow you to resolve them before continuing.'
        output: '[AI] The `--output` option in the `git patch` command specifies the file where the generated patch will be saved after applying the changes with `git apply`. If this option is not provided, the output of `git apply` is displayed in the terminal instead of saving it to a file.'
        posix: |-
            [AI] `git patch --posix` is a Git command used to apply a diff or patch file with POSIX-style format. POSIX, or Portable Operating System Interface for Unix, is a set of specifications for a uniform interface between applications and the operating system.

            When applying patches with `--posix`, Git assumes that all paths in the patch are relative to the current working directory (CWD). This can be useful when applying patches across different projects or repositories, as it minimizes the need to adjust absolute path references.

            Additionally, this command also sets the text editor to none by default, meaning that Git will not open an editor for you to review changes before committing. To apply the patch without any interactive confirmation, use `git apply --quiet --posix <patch_file>`.
        prefix: '[AI] The `--prefix` option in the `patch` command is used to specify a prefix that will be added to the beginning of filenames when applying patches. This can be useful when working with software packages or source code where multiple files may have the same name but different locations. For example, if you have a patch file for a library and want to install it in a custom location, you can use `--prefix` to tell `patch` to add a specific directory prefix to the filenames when they are applied. This ensures that the installed files do not overwrite existing files in other locations.'
        quiet: '[AI] The `--quiet` flag, also known as `-q`, is a common option used with various Unix-like utilities including `git` and `patch`. It is used to suppress informational messages and only display error messages. In the context of applying a patch file with `patch`, using `--quiet` will suppress normal output indicating that the patch has been applied successfully, resulting in a quieter application process.'
        quoting-style: |-
            [AI] `--quoting-style` is an option used with the `git diff` or `git apply` commands when dealing with patches containing filenames or text with special characters. It specifies the quoting style for these elements in the patch. The available options are:

            * `none`: No quoting is applied, which may lead to errors if filenames or text contain spaces or other special characters.
            * `c` (default): Use C-style quotes ("filename" or '\'filename\') around filenames and text with special characters.
            * `shell-esc`: Escape special characters in filenames and text using shell escapes (\filename or \'filename\').
            * `escape`: Escape all special characters in filenames and text (\\filename or \\'filename\\').

            Choosing the correct quoting style depends on the specific use case and the context where the patch will be applied.
        read-only: '[AI] The `patch --read-only` command is a utility in Git for applying a patch file to read-only files without modifying their original content. This can be useful when you want to preview the changes that would be made without actually making any modifications to the files themselves. The `--read-only` option ensures that no permanent changes are made during the patch application process.'
        reject-file: '[AI] The `--reject-file` option in Git''s `patch` command is used when applying a patch results in conflicts. With this option, Git creates a new file for each conflicting hunk, containing the conflicted sections with added markers indicating the conflicts. These files have the name of the input patch file with a "_rej" suffix appended. The developer can then edit these files to resolve the conflicts before committing the changes.'
        reject-format: '[AI] The `--reject-format` option is a flag used with Git''s `patch` command during a merge conflict resolution. It specifies the format for generating rejected patch files when a merge fails, i.e., when Git is unable to automatically merge two branches or commits. These rejected patches contain the conflicting changes that need manual review and resolution by developers. The default format for these patch files is `staged`, but other formats like `minimal` or `unified` can be specified using this flag, depending on your preferred conflict resolution workflow.'
        remove-empty-files: '[AI] The `--remove-empty-files` option in Git''s `patch` command removes files that are empty after applying a patch. This is useful when you want to ensure that files that were accidentally added or included only empty changes are removed from your working directory after applying the patch. By default, Git leaves empty files unchanged. However, using this flag will automatically remove them, keeping your working directory clean and up-to-date.'
        reverse: '[AI] `git patch --reverse` is a Git command used to apply a previously created patch file in reverse order. When a patch is applied using `git apply`, it introduces changes from the patch into the working directory or the staging area. With `--reverse`, the same patch is applied in reverse, undoing the changes that were made by the original application of the patch. This can be useful when you want to revert the effects of a patch without completely deleting it.'
        set-time: '[AI] `git patch --set-time` is a command used in Git for applying a patch file with a specific author date and commit time. When you apply a patch using this command, Git will ignore the current timestamp and instead use the ones provided in the patch file. This can be useful when you want to preserve the original author dates while applying patches across different branches or repositories.'
        set-utc: '[AI] `git patch --set-utc` is a command used with Git''s patch series feature. This command sets the UTC timezone for the patches in the series, meaning that the commit messages'' dates and times will be recorded in the UTC timezone when applying or creating new commits from the patch series. This can be useful for developers working across different timezones to ensure consistent timestamps for their collaborative work.'
        silent: '[AI] The `--silent` option, also referred to as `-q` or `--quiet`, is a common flag used with various Unix-like utilities including `git` and `patch`. When this flag is provided, it suppresses the output of informational messages during the execution of the command. The primary goal is to run the command without interruptions from unnecessary printouts, enhancing automation and reducing clutter in terminal logs.'
        strip: '[AI] `patch --strip` is a command used in version control systems, particularly with the GNU Patch tool, to remove a specified number of empty directories from the patch file being applied. This can be useful when dealing with nested directories and wanting to apply a patch directly to a specific subdirectory without having to navigate through all the intermediate levels. The argument to `--strip` is the number of directories to remove starting from the top level of the patch. For example, `patch --strip=2` would remove the first and second empty directory in the hierarchy before applying the patch.'
        suffix: '[AI] The `--suffix` option in Git''s `patch` command is used to specify a string that will be appended as a suffix to the filename extensions of the input patch files. This can be useful when dealing with patches that have conflicting filenames or when working on projects with complex naming conventions, as it allows you to easily identify which patches belong to which project or branch without having to manually rename the files. For example, `git am --suffix=_mybranch` would apply a patch file named `mypatch.patch` as `mypatch_mybranch.patch`.'
        unified: '[AI] `git patch --unified` is a command used to apply or create a difference file, also known as a patch file, between two versions of a file in Git. The `--unified` option specifies that the output patch file should be in the unified diff format, which is widely supported and easy to read. In this format, each hunk (a contiguous block of changes) is preceded by a header showing the source and destination files and paths, as well as the number of lines added or deleted within that hunk. This makes it easy for users to review and apply the changes interactively using tools like `git apply` or text editors.'
        verbose: '[AI] `patch --verbose` is a command-line option for the GNU Patch tool, which is used to apply or create difference files (patches) between two versions of a file. The `--verbose` option increases the level of output during patch application to provide detailed information about each hunk (a logical unit of change in a patch file) being applied. This can help diagnose any issues during patching, such as conflicts or unexpected changes.'
        version: '[AI] The `git patch --version` command is used to display the version information of the Git patch utility. It provides details such as the version number, commit hash, and other relevant information related to the installed Git patch tool. This command helps users to check if they have the latest version or not, and if not, they can take necessary steps to update it if required for compatibility with specific patch formats or features.'
        version-control: '[AI] The `--version-control` option in Git''s `patch` command is used to specify that the patch file being applied was created using a version control system, such as Git or SVN. When applying patches with this option, Git assumes that any hunks marked with the `@` symbol are annotations left by the version control system and adjusts the application accordingly. This helps ensure proper handling of patches when dealing with complex changesets or merges.'
