# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: commit
description: Record changes to the repository
group: main
flags:
    --ahead-behind: compute full ahead/behind values
    --allow-empty: allow recording an empty commit
    --allow-empty-message: allow recording a commit with an empty message
    --amend: amend previous commit
    --author=: override author for commit
    --branch: show branch information
    --cleanup=: 'how to strip spaces and #comments from message'
    --date=: override date for commit
    --dry-run: show what would be committed
    --fixup=: use autosquash formatted message to fixup specified commit
    --interactive: interactively add files
    --long: show status in long format (default)
    --no-ahead-behind: do not compute full ahead/behind values
    --no-edit: use the selected commit message without launching an editor
    --no-gpg-sign: don't GPG-sign the commit
    --no-post-rewrite: bypass post-rewrite hook
    --no-signoff: countermand an earlier --signoff
    --no-status: do not include the output of git-status in the commit message
    --pathspec-file-nul: pathspec elements are separated with NUL character
    --pathspec-from-file=: read pathspec from file
    --porcelain: machine-readable output
    --reset-author: the commit is authored by me now (used with -C/-c/--amend)
    --short: show status concisely
    --squash=: use autosquash formatted message to squash specified commit
    --status: include status in commit message template
    --trailer*=: add custom trailer(s)
    -C, --reuse-message=: reuse message from specified commit
    -F, --file=: read message from file
    -S, --gpg-sign?: GPG sign commit
    -a, --all: commit all changed files
    -c, --reedit-message=: reuse and edit message from specified commit
    -e, --edit: force edit of commit
    -i, --include: add specified files to index for commit
    -m, --message=: commit message
    -n, --no-verify: bypass pre-commit and commit-msg hooks
    -o, --only: commit only specified files
    -p, --patch: interactively add changes
    -q, --quiet: suppress summary after successful commit
    -s, --signoff: 'add Signed-off-by:'
    -t, --template=: use specified template file
    -u, --untracked-files?: show untracked files
    -v, --verbose: show diff in commit message template
    -z, --null: terminate entries with NUL
documentation:
    command: '[AI] `git commit` is a Git command used to save changes in the local repository into a new commitment with a message describing those changes. This command creates a snapshot of the project''s current state and writes this snapshot to the Git database, allowing you to record and track modifications over time. It does not push the commit to any remote repository; use `git push` for that.'
    flag:
        ahead-behind: '[AI] `git commit --ahead-behind` is a Git command used to check the relationship between the current branch and the remote one, in terms of commits that are not yet pushed or fetched. The command displays two numbers: the number of commits you have that aren''t on the remote (your local commits ahead), and the number of commits on the remote that aren''t on your local copy (remote commits behind). This information can help you decide whether it''s safe to push or pull changes.'
        all: '[AI] `git commit --all` is a Git command used to commit modifications in all current branches. When you run this command, Git will create a new commit for each branch with the staged changes at that moment. It''s equivalent to running `git add .` followed by `git commit` for each branch separately. This command can be useful when you want to make a commit for each branch with the same set of changes in one go. Keep in mind that committing all branches will create new commits for every branch, and it''s essential to ensure the changes are intended for those branches before running this command.'
        allow-empty: '[AI] `git commit --allow-empty` is a Git command used to create a new commit with an empty message or no message at all in the commit message text field. This option is useful when committing an empty file or a file with no changes, but still want to make a commit for record keeping purposes. The flag `--allow-empty` overrides Git''s default behavior of requiring a non-empty commit message.'
        allow-empty-message: '[AI] `git commit --allow-empty-message` is a command used in Git version control system to create a new commit with an empty or no message. By default, Git requires a commit message for every new commit, ensuring that each commit has a clear description of the changes made. However, there might be situations where you want to force-commit without providing a message, such as when setting up automated scripts or certain workflows. In such cases, the `--allow-empty-message` option is used to bypass this requirement and create a new commit with an empty or no message.'
        amend: '[AI] `git commit --amend` is a Git command used to modify the most recent commit message. It does not change the actual commit itself, but rather its associated message in the commit history. When you run this command, Git opens your default text editor with the current commit message, allowing you to edit and save changes. After saving, Git creates a new commit with the edited message and points `HEAD` to the amended commit. In essence, it allows you to correct or update the last commit''s message.'
        author: '[AI] The `git commit` command is used to record changes to your Git repository. The `--author` option allows you to specify an author name and email address different from your current Git configuration. This can be useful when committing changes made on someone else''s computer or if you want to keep your personal commit history separate from a shared project. In the command line, it would look like this: `git commit -m "commit message" --author="Name <email@example.com>"`'
        branch: |-
            [AI] `git commit --branch` is not a valid Git command as written. Instead, here are two common usage scenarios involving separate Git commands:

            1. `git commit -c <commit-message> -a --branch <new-branch>`
               This command creates a new commit with the given message and switches to the new branch. It's an efficient way to create and switch to a new branch from the current HEAD, without having to use intermediate Git commands like `git checkout -b`.

            2. `git commit <commit-message> --branch <existing-branch>`
               This command creates a new commit with the given message on the specified existing branch. It doesn't switch branches but keeps you on the current branch unless you use `git checkout <existing-branch>` afterwards.
        cleanup: '[AI] `git commit --cleanup` is a Git command used to clean up unnecessary files and directories in the staging area (index) before making a new commit. This can help keep the commit message focused on the changes being committed, as well as save disk space and improve performance by removing unneeded files. The command does not affect the local working directory or the Git history.'
        date: '[AI] The `git commit --date` command is used to create a new Git commit with a specified author date and committer date. The `--date` option allows you to set both the author and committer dates using various formats, such as "YYYY-MM-DD HH:MM:SS" or "AGO n hours" (where ''n'' is a number). For example, `git commit --date="2021-09-30 14:30:00"` sets both the author and committer dates to September 30, 2021 at 2:30 PM. This can be useful when creating a commit with an incorrect or missing timestamp, or when you want to force a specific date for a given commit in your Git history.'
        dry-run: '[AI] `git commit --dry-run` is a Git command that simulates a commit operation without actually creating a new commit in your repository. It''s used to check and preview the changes that will be included in the next commit, showing messages and parent commit information, but not modifying the commit history. This can help ensure correctness before executing an actual commit.'
        edit: |-
            [AI] `git commit --edit` is a Git command that allows you to create a new commit with the ability to edit the message in your text editor before it's actually committed. Here's a quick breakdown of what happens:

            1. The command `git add <file>` (or `git add .`) is typically used to stage the changes you want to commit. However, when using `--edit`, this step is skipped.
            2. Instead, `git commit --edit` opens your default text editor with an initial commit message.
            3. You can modify the message in the text editor as needed.
            4. Once you save and close the text editor, Git will create a new commit with your updated message.
            5. The staged changes are still committed along with the edited commit message.

            In summary, `git commit --edit` is an alternative way to create a commit where you can edit the commit message before it's actually committed, making it easier to craft well-written and descriptive commit messages.
        file: '[AI] `git commit --file` is a Git command used to create a new commit with only the changes from a specific file. The `--file` option takes the path to the file as an argument, and Git will include only those changes when creating the new commit. This command can be useful for committing changes to a single file without affecting other files in the working directory.'
        fixup: '[AI] The `git commit --fixup` command is a Git command used to modify the commit message of the last commit interactively, without creating a new commit. It sets up the editor with a special mode where only the first line of the message can be edited. This command is often used in conjunction with `git rebase -i` for squashing multiple commits into one while keeping their individual changes. Instead of manually editing each commit message during an interactive rebase, you can use `--fixup` to automatically update the message of the commit being squashed with the message of the next commit, allowing for a cleaner and more consistent commit history.'
        gpg-sign: '[AI] `git commit --gpg-sign` is a Git command used to create a new commit and sign it with your GPG key. This adds a digital signature to the commit, enhancing security and authenticity. The signed commit can be verified by others to confirm that it came from you and has not been tampered with.'
        include: '[AI] `git commit --include` is a Git command used to create a new commit with all the changes that are currently staged and also include any unstaged changes in the same commit. The `--include` option tells Git to include both staged and unstaged modifications when creating the commit, allowing developers to commit files with mixed states in a single commit. This can be useful for committing partially completed work or when preparing a feature branch for merging into another branch. However, using this command should be done with caution as it may lead to messy commit histories and potential conflicts.'
        interactive: '[AI] `git commit --interactive` is a Git command used to start an interactive rebase session in the text editor. It allows users to edit, squash, or reorder commits before creating a new commit message and finalizing the changes. This command enables more control over commit history and can be useful for preparing a clean and coherent commit log before pushing changes to a remote repository.'
        long: '[AI] `git commit --long` is a Git command used to make a new commit with a long, detailed message. The "--long" option allows entering a multi-line commit message by providing multiple `-m` flags and writing the messages between them. Each line after the first in the message is considered as part of the commit log message description, not a commit message summary. This command is useful for documenting more complex changes made to a project.'
        message: '[AI] The `git commit` command is used to record changes made to a file or project in Git version control system. The `--message` option allows you to provide a message that describes the changes being committed. This message should be informative and clear, helping other developers understand what was changed and why. The message can be provided as an argument to the command or written interactively using the text editor specified in the Git configuration. Once the commit message is confirmed, the changes are saved permanently in the version history.'
        no-ahead-behind: |-
            [AI] The `git commit --no-ahead-behind` command is used in Git version control system to create a new commit, but only if the current branch is up-to-date with the remote branch. If there are local commits that are not present on the remote branch (behind), or if the remote branch has commits that do not exist locally (ahead), this command will fail.

            The `--no-ahead-behind` flag ensures that Git only creates a new commit when both local and remote branches are in sync, avoiding potential conflicts or unwanted changes to the remote repository.
        no-edit: '[AI] `git commit --no-edit` is a Git command used to create a new commit with the current staging area changes without opening up an editor for the commit message. When you run this command, Git will generate a default commit message based on the most recent commit or the current branch''s `commit.template` file content if set. The changes will be committed immediately without any further interaction required.'
        no-gpg-sign: '[AI] `git commit --no-gpg-sign` is a Git command used to create a new commit without signing it with GPG (GNU Privacy Guard). This command can be useful in situations where you want to make a local commit quickly and don''t need or want to sign it at that moment. When this command is executed, Git will not prompt you for your GPG passphrase and the new commit will not be signed. If you later decide to sign the commit, you can use the `git commit --amend --sign-off` command.'
        no-post-rewrite: '[AI] `git commit --no-post-rewrite` is a Git command used to create a new commit without allowing any post-commit rebase or fast-forward operations on the current branch. In other words, it enforces that no changes can be made to the commits'' history after creating a new one. This option is useful when you want to preserve the commit history and avoid unintended modifications.'
        no-signoff: '[AI] `git commit --no-signoff` is a Git command used to create a new commit without signing off on the commit message. This means that the commit will not be associated with your personal email address and name by default, allowing another person to review or amend the changes before it is officially committed to the repository. This can be useful in collaborative development environments where code reviews are common practice. However, keep in mind that unsigned commits may not be accepted by some Git hosting services or project workflows.'
        no-status: '[AI] `git commit --no-status` is a Git command used to create a new commit without automatically opening the text editor for message input or showing the list of modified files in the staging area. The `--no-status` option disables the display of the current status before committing, allowing you to directly commit the changes that are already added to the staging area. This can be useful when you want to commit changes without reviewing the status or message first, but it''s generally recommended to double-check the files and messages before creating a new commit in most situations.'
        no-verify: '[AI] `git commit --no-verify` is a Git command used to create a new commit without automatically triggering the verification email for the listed email addresses, as configured in the `bash.rc`, `config` or `hooks/mail` files. It''s commonly used when you want to quickly commit changes without sending an email notification for every small change made during development. This can help save time and reduce clutter in your inbox. However, note that this command does not skip the verification step entirely; it simply suppresses the emails. The commits are still verified internally by Git.'
        "null": |-
            [AI] The `git commit --null` command is not a valid Git command. There is no such option as `--null` for the `commit` command in Git.

            If you meant to use `git add --nullable-rebase-index` instead, this command is used during a rebase process to tell Git that the file being staged has been intentionally deleted or removed from the working directory without committing it, and it should be marked as null in the commit message. This can be useful when doing interactive rebases where you want to remove specific files or changes without creating a new commit for them.
        only: |-
            [AI] `git commit --only` is not a valid Git command. There's no such option as "--only" for the `git commit` command. If you meant to use other options like `--interactive`, `--am`, or `--only-if-existing` with `git commit`, please specify that in your question.

            However, here's a brief explanation of some common `git commit` options:

            1. `--interactive`: Interactively pick which hunks from the staging area to include in the commit message. It opens up an editor for you to amend or squash commits.
            2. `--am`: Amend the last commit on the current branch. This allows you to change the commit message and make additional changes before creating a new commit.
            3. `--only-if-existing`: Only create a commit if there are already changes in the index (staging area). If no changes are found, it does nothing.
        patch: '[AI] `git commit --patch` is a Git command used to create a new commit after staging individual hunks or changes in a patch file. It opens the specified file(s) in your default text editor with each hunk marked, allowing you to review and edit the changes before committing. Once you save and close the editor, Git stages the hunks that have been modified, preparing them for the next commit. You can then use `git commit` to create the new commit with the staged changes. This command is useful when dealing with complex changes or resolving merge conflicts.'
        pathspec-file-nul: '[AI] The `git commit` command with the `--pathspec-file` option allows specifying a file containing list of paths to be included in the commit. The `--pathspec-file-nul` flag is an extension that when used, makes Git treat an empty file as an indication to commit all changed files, even if they are not explicitly listed in the given file. This can be useful when wanting to commit all changes but want to exclude some paths from being committed. With `--pathspec-file-nul`, an empty file signifies committing all changes, while a non-empty file contains the list of paths to include in the commit.'
        pathspec-from-file: '[AI] `git commit --pathspec-from-file` is a Git command used to commit changes to specific files or paths listed in a file instead of committing all changed files in the working directory by default. The `--pathspec-from-file` option specifies the path to such a file containing the list of paths to be committed. This can be useful when wanting to make multiple, selective commits from a set of changes.'
        porcelain: '[AI] `git commit --porcelain` is a command used in Git version control system for generating a customized, columnar output of committed files and their corresponding changeset messages. This output can be easily parsed by scripts or other automated tools to process commits data without requiring a full-fledged Git interface. The columns usually include the commit hash, author name, author email, timestamp, number of added/deleted lines, and the commit message itself.'
        quiet: '[AI] `git commit --quiet` is a Git command used to make a new commit with the current changes in the working directory, but it will suppress informational messages that are displayed by default when committing. This can be useful in scripts or automated workflows where you only need the commit to occur without seeing the output.'
        reedit-message: '[AI] `git commit --reedit-message` is a Git command used to change the message of the last committed message in the current branch. It opens up the text editor to allow users to edit and modify the message before saving and committing the new message. This can be useful if a mistake was made during the initial commit message entry or if additional information needs to be added. The command does not make any changes to the files themselves, only the commit message.'
        reset-author: '[AI] `git commit --reset-author` is a Git command used to reset the author and committer information of the most recent commit. It does not affect the content or message of the commit, only the author and committer names and email addresses. This can be useful if you accidentally committed with incorrect author information or need to update it for a centralized workflow. After running this command, Git will open the text editor to allow you to edit the author and committer details before saving and resetting the commit.'
        reuse-message: '[AI] `git commit --reuse-message` is a Git command used to create a new commit with the same message as the last commit. This can be useful when making multiple related commits in a row and wanting to keep the commit messages consistent. It saves time by reusing the previous commit message instead of having to write it again.'
        short: '[AI] `git commit --short` is a command used in Git version control system to create a new commit with a short message instead of a long one. The short message is limited to 52 characters, making it suitable for brief descriptions or abbreviations. This can be useful when making multiple commits quickly and preferring to keep the commit messages succinct. In contrast, `git commit` without any flags allows a full commit message with more than 52 characters.'
        signoff: '[AI] The `git commit --signoff` command is used to add your name and email address to a Git commit message, signifying that you have reviewed and confirm the commit''s content. This is often required in open-source projects to ensure accountability for the changes made. It sets the `GIT_COMMITTER_IDENT` and `GIT_COMMITER_NAME` environment variables with your name and email during the commit process. Additionally, it appends the `--no-edit` flag to prevent opening the editor for commit message modification, allowing only the specified message or the one previously staged to be used.'
        squash: '[AI] `git commit --squash` is a Git command used to combine multiple consecutive commits into a single one with a custom commit message. It allows you to edit the messages and messages history before creating the final squashed commit. This can be useful for keeping a cleaner, more linear commit history.'
        status: '[AI] `git commit --status` is a Git command used to check the current state of files in the working directory before committing them. The command displays the list of files with modifications, new files, and deleted files that will be included in the next commit, without actually creating a new commit. This can help users review their changes before finalizing their commitment.'
        template: '[AI] `git commit --template` is a Git command used to create or update a template file for use with the `git commit` message editor. The `--template` option specifies the path to a file containing the desired message format. When invoked, Git will use this file as the initial content of the commit message editor, allowing users to customize their commit messages based on the provided template. This can help ensure consistent formatting and messaging across a project.'
        trailer: '[AI] `git commit --trailer` is a command used in Git version control system to set or modify the trailer text for a commit message. Trailer is additional metadata that can be attached to a Git commit and displayed below the commit message when viewing the commit history. This can be useful for storing standardized information such as issue numbers, JIRA keys, or other relevant data associated with each commit. The command takes the trailer text as an argument and sets it for the next commit. For example: `git commit --amend --trailer="Jira: ABC-123" <files>` would amend the last commit message and add "Jira: ABC-123" as its trailer.'
        untracked-files: '[AI] The `git commit --untracked-files` command is used to create a new Git commit with all currently untracked (new and modified files that are not being ignored by Git) files in the current repository. This command does not affect or include tracked files, meaning files that have been added to the Git index with `git add`. By using this command, you''re committing only the changes in untracked files, which might be useful when you want to commit new files that aren''t yet ready for a regular commit or when working on separate features within a repository. Remember that committing untracked files will include them in the Git history and make them part of the project''s version control.'
        verbose: '[AI] `git commit --verbose` is a Git command used to create a new commit with extra output detailing the changes being committed. The `--verbose` option increases the amount of information displayed during the commit process, including the name and path of each file being modified, as well as the diff statistics for each change. This can be helpful for understanding exactly what is being committed and ensuring that the desired changes are being captured in the new commit.'
