# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: log
description: Show commit logs
group: main
flags:
    --abbrev-commit: Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely.
    --abbrev=: Show the shortest prefix that is at least <n> hexdigits long that uniquely refers
    --after=: Show commits more recent than a specific date.
    --all: Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.
    --all-match: Limit the commits output to ones that match all given --grep, instead of ones that match at least one.
    --alternate-refs: Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line.
    --ancestry-path: When given a range of commits to display, only display commits that exist directly on the ancestry chain.
    --anchored=: Generate a diff using the "anchored diff" algorithm.
    --author-date-order: Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order.
    --author=: Limit the commits output to ones with author/committer header lines that match the specified pattern
    --basic-regexp: Consider the limiting patterns to be basic regular expressions; this is the default.
    --before=: Show commits older than a specific date.
    --binary: In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.
    --bisect: Pretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line.
    --boundary: Output excluded boundary commits. Boundary commits are prefixed with -.
    --branches=: Pretend as if all the refs in refs/heads are listed on the command line as <commit>.
    --check: Warn if changes introduce conflict markers or whitespace errors.
    --cherry: A synonym for --right-only --cherry-mark --no-merges
    --cherry-mark: Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.
    --cherry-pick: Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.
    --children: Print also the children of the commit.
    --color-moved-ws?: This configures how whitespace is ignored when performing the move detection for --color-moved.
    --color-moved?: Moved lines of code are colored differently.
    --color-words=: Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.
    --color?: Show colored diff.
    --combined-all-paths: This flag causes combined diffs (used for merge commits) to list the name of the file from all parents.
    --committer=: Limit the commits output to ones with author/committer header lines that match the specified pattern
    --compact-summary: Output a condensed summary of extended header information.
    --cumulative: Synonym for --dirstat=cumulative
    --date-order: Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order.
    --date=: Only takes effect for dates shown in human-readable format, such as when using --pretty.
    --decorate-refs-exclude=: Do not decorete refs matching pattern.
    --decorate-refs=: Decorate refs matching pattern.
    --decorate?: Print out the ref names of any commits that are shown.
    --diff-algorithm=: Choose a diff algorithm.
    --diff-filter?: Select only files that are of given change.
    --diff-merges=: Specify diff format to be used for merge commits.
    --dirstat-by-file=: Synonym for --dirstat=files,param1,param2...
    --do-walk: Overrides a previous --no-walk.
    --dst-prefix=: Show the given destination prefix instead of "b/".
    --encoding=: Commit objects record the character encoding used for the log message in their encoding header.
    --exclude-first-parent-only: When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit.
    --exclude=: Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider.
    --expand-tabs=: Perform a tab expansion
    --ext-diff: Allow an external diff helper to be executed.
    --find-copies-harder: For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset.
    --find-object=: Look for differences that change the number of occurrences of the specified object.
    --first-parent: When finding commits to include, follow only the first parent commit upon seeing a merge commit.
    --follow: Continue listing the history of a file beyond renames (works only for a single file).
    --format?: Pretty-print the contents of the commit logs in a given format
    --full-diff: With this, the full diff is shown for commits that touch the specified paths
    --full-history: Same as the default mode, but does not prune some history.
    --full-index: Instead of the first handful of characters, show the full pre- and post-image blob object names on the "index" line when generating patch format output.
    --glob=: Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>.
    --graph: Draw a text-based graphical representation of the commit history on the left hand side of the output.
    --grep-reflog=: Limit the commits output to ones with reflog entries that match the specified pattern
    --grep=: Limit the commits output to ones with log message that matches the specified pattern
    --histogram: Generate a diff using the "histogram diff" algorithm.
    --ignore-blank-lines: Ignore changes whose lines are all blank.
    --ignore-cr-at-eol: Ignore carriage-return at the end of line when doing a comparison.
    --ignore-missing: Upon seeing an invalid object name in the input, pretend as if the bad input was not given.
    --ignore-space-at-eol: Ignore changes in whitespace at EOL.
    --ignore-submodules?: Ignore changes to submodules in the diff generation.
    --indent-heuristic: Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.
    --inter-hunk-context=: Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other.
    --invert-grep: Limit the commits output to ones with log message that do not match the pattern specified with --grep=<pattern>.
    --ita-invisible-in-index: . This option makes the entry appear as a new file in "git diff" and non-existent in "git diff --cached".
    --left-only: List only commits on the respective side of a symmetric difference.
    --left-right: Mark which side of a symmetric difference a commit is reachable from.
    --line-prefix=: Prepend an additional prefix to every line of output.
    --log-size: Include a line “log size <number>” in the output for each commit.
    --mailmap: Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses.
    --max-parents=: Show only commits which have at least (or at most) that many parent commits.
    --merge: After a failed merge, show refs that touch files having a conflict and don’t exist on all heads to merge.
    --merges: Print only merge commits. This is exactly the same as --min-parents=2.
    --min-parents=: Show only commits which have at least (or at most) that many parent commits.
    --minimal: Spend extra time to make sure the smallest possible diff is produced.
    --name-only: Show only names of changed files.
    --name-status: Show only names and status of changed files.
    --no-abbrev-commit: Show the full 40-byte hexadecimal commit object name.
    --no-color: Turn off colored diff.
    --no-color-moved: Turn off move detection.
    --no-color-moved-ws: Do not ignore whitespace when performing move detection.
    --no-decorate: Print out the ref names of any commits that are shown.
    --no-diff-merges: Specify diff format to be used for merge commits.
    --no-expand-tabs: Do not perform a tab expansion
    --no-ext-diff: Disallow external diff drivers.
    --no-indent-heuristic: Disable the indent heuristic.
    --no-mailmap: Do not use mailmap file to map author and committer names and email addresses to canonical real names and email addresses.
    --no-max-parents: Show only commits which have at least (or at most) that many parent commits.
    --no-merges: Do not print commits with more than one parent. This is exactly the same as --max-parents=1.
    --no-min-parents: Show only commits which have at least (or at most) that many parent commits.
    --no-notes: Do not show notes.
    --no-prefix: Do not show any source or destination prefix.
    --no-relative: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.
    --no-rename-empty: Whether to use empty blobs as rename source.
    --no-renames: Turn off rename detection, even when the configuration file gives the default to do so.
    --no-textconv: Disallow external text conversion filters to be run when comparing binary files.
    --no-use-mailmap: Do not use mailmap file to map author and committer names and email addresses to canonical real names and email addresses.
    --no-walk?: Only show the given commits, but do not traverse their ancestors.
    --not: Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not.
    --notes=: Show the notes that annotate the commit
    --numstat: Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation.
    --oneline: This is a shorthand for "--pretty=oneline --abbrev-commit" used together.
    --output-indicator-context=: Specify the character used to indicate context lines in the generated patch.
    --output-indicator-new=: Specify the character used to indicate new lines in the generated patch.
    --output-indicator-old=: Specify the character used to indicate old lines in the generated patch.
    --output=: Output to a specific file instead of stdout.
    --parents: Print also the parents of the commit.
    --patch-with-raw: Synonym for -p --raw.
    --patch-with-stat: Synonym for -p --stat.
    --patience: Generate a diff using the "patience diff" algorithm.
    --pickaxe-all: When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.
    --pickaxe-regex: Treat the <string> given to -S as an extended POSIX regular expression to match.
    --pretty?: Pretty-print the contents of the commit logs in a given format
    --raw: For each commit, show a summary of changes using the raw diff format.
    --reflog: Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>.
    --relative-date: Synonym for --date=relative.
    --relative=: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.
    --remotes=: Pretend as if all the refs in refs/remotes are listed on the command line as <commit>.
    --remove-empty: Stop when a given path disappears from the tree.
    --rename-empty: Whether to use empty blobs as rename source.
    --reverse: Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs.
    --right-only: List only commits on the respective side of a symmetric difference.
    --rotate-to=: Discard the files before the named <file> from the output (i.e.  skip to), or move them to the end of the output (i.e.  rotate to).
    --shortstat: Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.
    --show-linear-break=: When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch.
    --show-pulls: Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent.
    --show-signature: Check the validity of a signed commit object by passing the signature to gpg --verify and show the output.
    --simplify-by-decoration: Commits that are referred by some branch or tag are selected.
    --simplify-merges: First, build a history graph in the same way that --full-history with parent rewriting does.
    --since=: Show commits more recent than a specific date.
    --single-worktree: This option forces them to examine the current working tree only.
    --skip-to=: Discard the files before the named <file> from the output (i.e.  skip to), or move them to the end of the output (i.e.  rotate to).
    --skip=: Skip number commits before starting to show the commit output.
    --source: Print out the ref name given on the command line by which each commit was reached.
    --sparse: All commits that are walked are included.
    --src-prefix=: Show the given source prefix instead of "a/".
    --stat=: Generate a diffstat.
    --stdin: In addition to the <commit> listed on the command line, read them from the standard input.
    --submodule=: Specify how differences in submodules are shown.
    --summary: Output a condensed summary of extended header information such as creations, renames and mode changes.
    --tags=: Pretend as if all the refs in refs/tags are listed on the command line as <commit>.
    --textconv: Allow external text conversion filters to be run when comparing binary files.
    --topo-order: Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed.
    --until=: Show commits older than a specific date.
    --use-mailmap: Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses.
    --word-diff-regex=: Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word.
    --word-diff?: Show a word diff, using the <mode> to delimit changed words.
    --ws-error-highlight?: Highlight whitespace errors in the context, old or new lines of the diff.
    -B, --break-rewrites=: Break complete rewrite changes into pairs of delete and create.
    -C, --find-copies=: Detect copies as well as renames.
    -D, --irreversible-delete: Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null.
    -E, --extended-regexp: Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.
    -F, --fixed-strings: Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).
    -G=: Look for differences whose patch text contains added/removed lines that match <regex>.
    -I, --ignore-matching-lines=: Ignore changes whose all lines match <regex>.
    -L=: Trace the evolution of the line range given by <start>,<end>, or by the function name regex <funcname>, within the <file>.
    -O=: Control the order in which files appear in the output.
    -P, --perl-regexp: Consider the limiting patterns to be Perl-compatible regular expressions.
    -R: Swap two inputs
    -S=: Look for differences that change the number of occurrences of the specified string.
    -U, --unified=: Generate diffs with <n> lines of context instead of the usual three.
    -W, --function-context: Show whole function as context lines for each change.
    -X, --dirstat=: Output the distribution of relative amount of changes for each sub-directory.
    -a, --text: Treat all files as text.
    -b, --ignore-space-change: Ignore changes in amount of whitespace.
    -g, --walk-reflogs: Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones.
    -i, --regexp-ignore-case: Match the regular expression limiting patterns without regard to letter case.
    -l=: This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.
    -n, --max-count=: Limit the number of commits to output.
    -p, --patch: Generate patch.
    -s, --no-patch: Suppress diff output.
    -t: Show the tree objects in the diff output.
    -w, --ignore-all-space: Ignore whitespace when comparing lines.
    -z: Separate the commits with NULs instead of with new newlines.
documentation:
    command: '[AI] `git log` is a Git command used to view the commit history of a repository. It displays a list of commits, each showing the author, date, message, and other relevant information. By default, it shows the most recent commits, but you can use various options to filter and customize the output based on specific criteria such as author, search terms, or range of commits.'
    flag:
        G: '[AI] The `git log` command with the `-G` option is used to search for and show commits that introduce or modify a specific regular expression pattern in the file content. It searches through the blob objects in the commit history, and returns the commits where the changes introduced or modified the specified pattern. This can be useful when trying to find commits that introduced a particular bug fix or change in the codebase.'
        L: '[AI] `git log -L` is a Git command used to show the commit history that introduced or modified a specific line or lines in a file. The option `-L` followed by a number and a path specifies the line(s) and file(s) to search in the commit messages. For instance, `git log -L 5,10 myfile.txt` shows the commits that changed lines 5 through 10 of `myfile.txt`.'
        O: '[AI] `git log -O` is a Git command used to show the commit history with the files that have been modified in each commit. The option `-O` (or `--on-each-commit`) makes Git output the name of the file(s) that had changes committed in each log message, along with the usual commit hash, author, and date information.'
        R: '[AI] The `git log -R` command is used to display the commit history for a specific repository, but with the added ability to follow and show changes made to files recursively in subdirectories. The `-R` option stands for "recursive" and tells Git to show commits that affect any file or directory within the project, including those in nested directories. This is particularly useful when investigating large codebases with multiple levels of subdirectories.'
        S: '[AI] `git log -S` is a Git command used to show the history of commits that changed a specific file or introduced a particular string into the source code. The `-S` option makes Git search for strings in the committed files instead of just the commit messages. It displays each commit with the added or modified lines containing the searched string and the number of additions and deletions. This command is helpful when trying to find which commits introduced a specific change into the codebase.'
        abbrev: '[AI] The `git log --abbrev` command is used to display the abbreviated commit messages in a git log output. The `--abbrev` option shortens each commit message to just the first 50 characters, making it easier to view multiple commit messages at a glance. By default, `git log` shows the full commit message for each commit.'
        abbrev-commit: '[AI] `git log --abbrev-commit` is a Git command used to display the commit messages and abbreviated commit hashes (instead of the full hash) for a specified number of commits in the project''s history. This can make it easier to read and compare commit information when viewing multiple commits at once. The abbreviated hash is the first 7 characters of a Git commit hash.'
        after: '[AI] `git log --after` is a Git command used to display the commit history with only the commits that were made after a specific date or commit hash. The `--after` option filters the output to show only the commits that came after the given argument, which can be a date in the format "YYYY-MM-DD" or a commit hash. This command is useful for reviewing recent changes or focusing on a specific branch''s development since a particular point.'
        all: '[AI] `git log --all` is a Git command used to display the commit history across all branches in a repository. The ''--all'' option allows you to view commits from any branch or tag, providing a comprehensive view of the entire project history. Each commit shows its hash, author, date, and message. This command is useful for tracking down bugs, comparing branches, or gaining an understanding of the development history.'
        all-match: |-
            [AI] `git log --all-match` is not a valid Git command. There seems to be a mistake in the name of the command. Instead, you might be looking for one or more of the following Git commands:

            1. `git log --all`: This command shows the commit history across all branches and tags. It's equivalent to running `git log master main --all`.
            2. `git log --grep <pattern> --all`: This command searches for a specific string in the commit messages of the entire Git repository, across all branches and tags. For example, `git log --grep="fixed bug" --all` will return commits that contain "fixed bug" in their commit message.
            3. `git log --oneline --all`: This command displays the abbreviated commit messages for the entire Git repository history, across all branches and tags.

            Please review the correct Git command based on your requirements to achieve the desired outcome.
        alternate-refs: '[AI] `git log --alternate-refs` is a Git command used to view the commit history with references that are not the default (or "canonical") refs. These alternative refs could be branches or tags that exist locally but don''t have corresponding remote counterparts, or they could be remote tracking branches that haven''t been fetched yet. This command provides a more comprehensive view of the Git history by including these alternate references alongside the canonical ones when displaying the log output.'
        ancestry-path: '[AI] `git log --ancestry-path` is a Git command that displays the ancestry of commits in the form of a hierarchical path, showing the chain of parent commits leading to the current branch tip or specified commit. It provides a clear visualization of the committing history and the relationships between different branches or commits. The output shows each commit and its parent commit(s), represented as a series of nested directories in the command''s output.'
        anchored: '[AI] The `git log --anchored` command displays the commit history with only the commit messages for commits that have a parent commit, called an "ancestor commit." These are often called "non-merge commits" because they don''t introduce new branches. This command can be useful when you want to see a clean list of the commits that were made on a specific branch without merge commits or other complexities.'
        author: '[AI] `git log --author` is a Git command that displays the commit history with only the commits authored by a specific author. You can specify an author name or email address to filter the results. This command helps in reviewing the changes made by a particular author in a project''s Git repository.'
        author-date-order: '[AI] `git log --author-date-order` is a Git command that displays commit history with commits listed in reverse chronological order based on their author dates instead of their commitment dates. This means that each commit will be displayed with its corresponding author and the date when it was authored, rather than the date when it was committed. It''s often used to view the development history from an author perspective or to trace down changes made by a specific author over time.'
        basic-regexp: '[AI] `git log --basic-regexp` is a Git command used to filter and display commits based on a given regular expression pattern in the commit messages. The `--basic-regexp` option enables the use of regular expressions with basic regexp syntax, allowing for more complex filtering than simple string matching offered by the `--grep` or `--search` options. This command helps to quickly find commits that meet specific criteria based on their messages.'
        before: '[AI] The `git log --before` command is used to show the commit history of a repository up to a specific point in time or commit hash. The `--before` option filters the commits shown in the log to only those that were committed before the given date or commit. This can be useful when trying to find the cause of a problem that occurred at a certain point in the project''s history, as it allows you to view the changes leading up to that point without being distracted by later commits. The output includes the commit message, author information, and hash for each selected commit.'
        binary: '[AI] `git log --binary` is a Git command used to display the binary file changes between two commit versions in a binary diff format. This means that instead of showing the changes as text-based differences, it presents them in their original binary form using a standard binary diff algorithm such as Unified Diff or Raw Format. It is particularly useful when working with files containing binary data like images, executables, or compressed archives where textual diffs are not meaningful.'
        bisect: '[AI] `git log --bisect` is a Git command used to perform a binary search for the commit that introduced a particular bug or regression. It automates the process of finding the offending commit by incrementally checking commits on either side of where it''s believed to be located based on user input. The command takes two arguments: the commit message or hash of the good (working) commit and the bad (broken) commit, and Git will output the sequence of commits that likely contain the offending change. Users can then inspect these commits to identify and revert the error.'
        boundary: '[AI] `git log --boundary` is a Git command used to show the committed history with only the commit messages, but it includes only the commits that are reachable from the current branch tip and the first parent of the initial commit (also known as the root or boundary commits). This command filters out any merge commits and empty commits, providing a cleaner view of the committed changes.'
        branches: '[AI] The `git log --branches` command displays the commits on all branches that have merged into the current branch, showing the merge commit messages and the branches they came from. It provides a summary of merges in reverse chronological order, allowing users to easily track merge history and identify potential conflicts or issues.'
        break-rewrites: '[AI] `git log --break-rewrites` is a Git command that displays the commit history of a repository, but it prevents fast-forward and merge commits from being rewritten by subsequent commits. In other words, it preserves the commit history even if some commits have been modified or deleted by later commits. This can be useful when investigating complex histories or merging branches with conflicting commits.'
        check: '[AI] `git log --check` is a Git command that performs a dry-run, or simulation, of a commit in the current branch. It checks if the current changes can be committed without any conflicts. If there are any conflicts, Git will show an error message indicating which files have conflicting changes. This command helps prevent unintended commits and ensures a clean and conflict-free commit history.'
        cherry: '[AI] `git log --cherry` is a Git command used to compare the difference between two branches or commits in a compact and succinct format. It shows a summary of the commits that are unique to each branch, indicating which commits have been shared and which ones are exclusive. This can be useful for identifying merge conflicts or understanding the divergence between two branches. The output is typically displayed with one commit per line, with the branch name prefixing each entry.'
        cherry-mark: '[AI] `git log --cherry-mark` is a Git command used to display commit history with cherry-pick marks. Cherry-pick is a Git operation for applying commits from one branch to another. With the `--cherry-mark` option, Git will append a "+" sign to commits that have been applied cleanly as a cherry-pick, and a "*" sign if there were conflicts during the application process. This can help quickly identify which commits were successfully applied as cherry-picks and which ones required manual intervention to resolve any potential conflicts.'
        cherry-pick: '[AI] `git log --cherry-pick` is a Git command used to apply individual commits from one branch onto another, as if they were cherry-picked interactively. It does not create new commits but rather applies the changes directly to the current branch. The command shows the commits applied with their hash, parent hashes, and messages, allowing you to review each change before applying it. If you want to apply a specific commit from another branch without creating a merge commit, this is the command to use.'
        children: '[AI] The `git log --children` command displays the commit history with only the commits that are direct parents to a given commit or branch tip. It provides a compact view of the hierarchy of commits that directly contribute to the current state of the repository. This can be useful for understanding the lineage of changes and identifying the sequence of events leading up to a particular point in the project''s history.'
        color: '[AI] `git log --color` is a Git command that displays commit messages and their corresponding author information in colored text for improved readability. The `--color` option enables colored output, making it easier to distinguish between different types of commits such as author name, branch names, and commit messages. This command shows the commitment history with useful information like the author, date, and message, but with the added benefit of having the information displayed in colors for better visual distinction.'
        color-moved: '[AI] The `git log --color-moved` command is used to display a colored git log output with information about moved or renamed files. This can be helpful when tracking changes related to file renames within a Git repository. When you run this command, Git will show each commit with the old and new file names (if applicable) next to it, making it easier to follow the history of the file''s name changes.'
        color-moved-ws: '[AI] `git log --color-moved-ws` is a Git command that displays the commit history with colored text to highlight moved or renames files and their corresponding new names. The `--color-moved-ws` option enables coloring for moved files across multiple commits, making it easier to identify file renames in the output.'
        color-words: '[AI] `git log --color-words` is a Git command that displays the commit message history with colored words for easier identification of author names, commit messages, and branches in the output. The `--color-words` option enables Git to automatically color specific parts of the commit messages based on predefined keywords, such as branch names or merge messages. This can make it simpler to visually distinguish different types of commits in the log.'
        combined-all-paths: |-
            [AI] `git log --combined-all-paths` is not a standard Git command. However, it seems like you might be trying to use a combination of Git commands to view the history of files with their corresponding changes in a single output.

            The `git log` command is used to display the commit history. The `--combined-all` option shows each commit message followed by the differences between parent and child commits, making it easier to see the changes introduced at each step.

            To include the file paths for each change in this combined output, you can use the following command:

            ```bash
            git log --pretty=format:'%h %s' --name-only --date=short HEAD^..HEAD
            ```

            This will show you a list of commits, with each commit message followed by a list of files that were modified in that commit.

            Keep in mind that this command only shows the difference between the last parent (HEAD^) and the current commit (HEAD), meaning it may not be exactly what you're looking for if you want to see the history of all commits affecting a specific file or set of files. In such cases, you may need to use more advanced Git commands like `git log --follow <file_path>` or `git blame <file_path>`.
        committer: '[AI] The `git log --committer` command displays the committed history in Git, showing each commit''s author information, which includes the committer''s name and email address. This information is useful for understanding who made each commit and when it was done. Additionally, other details like the commit message, parent commit hash, and timestamp are also displayed along with the committer information.'
        compact-summary: '[AI] `git log --compact-summary` is a Git command used to display a compact summary of the commits in the current branch or specified range. It shows each commit''s hash, author, and message in a single line with the number of added and deleted lines for each commit. This makes it an effective way to quickly view the commit history with essential information.'
        cumulative: '[AI] `git log --cumulative` is a Git command that displays commit messages in a compact, columnar format. The `--cumulative` option merges adjacent committer names and their corresponding commit messages into a single line when they share the same author history. This provides a clear view of the commit history with respect to the order in which changes were made and by whom. It''s useful for understanding how different branches evolved from a common ancestor or tracking down complex merge conflicts.'
        date: '[AI] `git log --date` is a Git command used to display commit history with the commitment dates shown in a specific format. The `--date` option allows specifying different formats for the date output, such as "iso", "short", or "relative" (default). This can be useful when dealing with large commit histories or when trying to identify commits based on their relative age.'
        date-order: '[AI] `git log --date-order` is a Git command used to display commit history in chronological order based on the committed date. This option allows you to see the commits in their actual timeline, making it easier to understand the sequence of events and identify when each change was made. The output will show each commit message, author, parent commits, and the committed date, listed from oldest to most recent.'
        decorate: '[AI] `git log --decorate` is a Git command that displays the commit history with branch labels decorated on the commit messages. With this option, instead of just seeing the hash and message for each commit, you will also see the branch names associated with those commits. This can make it easier to follow the relationship between commits and branches in your Git repository.'
        decorate-refs: '[AI] `git log --decorate-refs` is a Git command used to display the commit history with ref names (branches or tags) decorated on each commit message. The `--decorate-refs` option tells Git to show not only the default local branch names but also remote tracking branches and tags. This allows you to easily visualize the relationship between commits, branches, and tags in your repository.'
        decorate-refs-exclude: '[AI] `git log --decorate-refs --decorate-refs-exclude=<ref>` is a Git command used to display the commit history with decorator labels on the branch and tag names. The `--decorate-refs` option enables this feature, while the `--decorate-refs-exclude` option excludes a specific ref from being shown as a decorator label in the output. For instance, if you have both a local branch named "feature" and a remote tracking branch named "origin/feature", running `git log --decorate-refs --decorate-refs-exclude=origin/feature` will display the commit history with only the local feature branch decorator label.'
        diff-algorithm: |-
            [AI] The `git log --diff-algorithm` command is used to specify the difference algorithm for the diff output when using Git's `log` command. There are three available algorithms: `minimal`, `patch`, and `histogram`.

            * `--diff-filter=minimal`: It produces the minimal diff output, which only shows the header lines of added or deleted files in the commit, without the actual contents of the changes. This is useful for quickly identifying which files were changed in a commit without having to see the full diff.
            * `--diff-filter=patch`: It generates the standard unified format diff output, showing both the added and deleted lines for each hunk in the commit. This is the default diff algorithm when no option is specified.
            * `--diff-filter=histogram`: It displays a histogram of additions, deletions, and modifications for each file in the commit. This can be helpful for quickly identifying files with large numbers of changes, or for analyzing trends in the size and composition of commits over time.
        diff-filter: '[AI] `git log --diff-filter` is a Git command that shows the differences between commits in a more fine-grained way than the default output of `git log`. The `--diff-filter` option allows filtering the output based on the type of changes introduced by each commit. For example, you can use `--diff-filter=M` to show only commits that modified files (as opposed to commits that changed metadata only), or `--diff-filter=d` to show commits that deleted files. This option is useful when you want to focus on specific types of changes in a Git history.'
        diff-merges: '[AI] The `git log --diff-merges` command displays a log of commits where a merge commit was used to combine changes from multiple branches. Each commit in the output is shown with its hash, author, date, and message. The real value is in the difference output between the two parent commits that shows the changes merged in that commit. This command helps understand how different branches were integrated into the mainline of development.'
        dirstat: '[AI] `git log --dirstat` is a Git command that generates a statistical summary of file and directory changes between each commit in the current branch or specified commits. It shows the number of added, modified, and deleted files and directories, as well as the percentage of changes within each category. This can be helpful for understanding the impact of specific commits on the repository''s file structure.'
        dirstat-by-file: '[AI] `git log --dirstat-by-file` is a Git command that generates a summary of file modifications for each commit in the current branch or specified range. It shows the number of added, modified, and deleted bytes for each file. The output is presented in a tabular format where columns represent files and rows represent commits. This command is useful for understanding the impact of changes made at the file level across multiple commits.'
        do-walk: '[AI] `git log --do-walk` is a Git command that performs a depth-first traversal of the committed history, visiting each commit exactly once. It returns the commit objects as output, in reverse chronological order. This can be useful for scripts and other automated processes to iterate through commits and extract information from them.'
        dst-prefix: '[AI] `git log --dst-prefix` is a Git command that displays the commit history with a prefix indicating the shortest common ancestor (SCA) of the commits being listed. The `--dst-prefix` option makes Git show each commit message preceded by the commit message of its most recent common ancestor, making it easier to see the evolution of changes in a branch or across multiple branches.'
        encoding: '[AI] `git log --encoding` is a Git command that displays the commit logs with encoding information. The `--encoding` option specifies that the output should include the committer encoding declaration, which indicates the character encoding used for the commit message and author name. This can be useful when working with non-ASCII characters or different encodings in a multi-author project.'
        exclude: '[AI] The `git log --exclude` command is used to show the commit history with specific commits excluded from the output. The exclusion is defined by providing a list of commit hashes, branch names, or regular expressions as arguments to the `--grep-file` or `--author` options. For example, `git log --exclude="commit-hash" --pretty=oneline` will display all commits in the history except the one with the specified hash. This can be useful when you want to focus on a specific part of the commit history and filter out irrelevant commits.'
        exclude-first-parent-only: '[AI] The `git log --exclude-first-parent` command displays the commit history with certain branching structures hidden. Unlike `--first-parent-only`, which only shows commits on the current branch and their direct parents, `--exclude-first-parent` also includes commits that deviate from a strict first-parent chain by having additional parents. This can be useful when dealing with more complex merge or rebase scenarios where multiple branches were combined into a single commit history.'
        expand-tabs: '[AI] `git log --expand-tabs` is a Git command used to display commit messages with expanded tabs in the output. By default, Git represents tab characters as multiple spaces in the log output. However, `--expand-tabs` option expands those tab characters into actual tabs, making it easier for users to read and compare files changed in the commits.'
        ext-diff: '[AI] `git log --ext-diff` is a Git command used to display the commit history with extended diff information for each commit. This option allows external diff tools to be used for generating and displaying the difference between commits. Instead of showing the differences within the Git terminal, it passes the commits'' paths to an external tool specified in the `git config` or environment variables. It is particularly useful when dealing with large or complex changes that are hard to review within Git''s default diff output.'
        extended-regexp: '[AI] `git log --extended-regexp` is a Git command used to display the commit history with a search pattern as a regular expression in the message or commit hash. This command filters the output of `git log` based on the provided regex. For instance, `git log --extended-regexp=''fix:.*bug''` will only show commits with messages starting with "fix:" followed by any characters and the word "bug". It is an efficient way to search for specific commits based on their message content.'
        find-copies: '[AI] `git log --find-copies` is a Git command used to find commits that introduced a copy of a specific file in a repository, or commits where a file was moved and then copied elsewhere. This can be useful when tracking down the history of file renames or moves within a project. The output shows each commit with the relevant information about the file change, such as the author, commit message, and the new location of the file (if it was moved).'
        find-copies-harder: '[AI] `git log --find-copies-harder` is a Git command used to trace the history of file copies and renames across branches or commit trees. It extends the functionality of regular `git log` commands by following the history of moved or duplicated files more thoroughly, enabling users to find the origin and evolution of each instance. This is especially useful when dealing with complex codebases that undergo frequent refactoring and file manipulations.'
        find-object: '[AI] `git log --find-object` is a Git command used to find and display the commit objects that match a given object name or hash. It searches through the repository''s reachable history, starting from the current HEAD, to locate commits with the specified object. The output shows the log message, author information, and commit hash for each matching commit. This command can be useful when investigating specific commits or objects in a Git repository.'
        first-parent: '[AI] The `git log --first-parent` command is used to display the commit history of a branch or a specific commit, showing only the commits on the main branch (also known as the "first-parent" branch). This means that merges and other non-linear commits will be hidden. It''s particularly useful for following the linear development path of a project where commits are made directly on the master branch.'
        fixed-strings: '[AI] `git log --fixed-strings` is a Git command used to show commits with a specific, exactly matching string in the commit message. The `--fixed-strings` option ensures that only exact matches are found and not substring matches, making the search results more precise. This command can help identify commits that introduced or modified a particular text string within a project''s history.'
        follow: '[AI] `git log --follow` is a Git command used to trace the commit history of a repository, following the changes made to a file or a set of files over multiple commits. This command is particularly useful when tracking complex edits, such as those involving renaming or moving files, where the standard `git log` may not provide a clear view of the entire history. With `--follow`, Git will automatically connect the dots between commits that modify related files, showing you the evolution of the file in its entirety.'
        format: '[AI] `git log --format` is a Git command used to customize the output format of the `git log` command. The `--format` option allows specifying a template to control how the commit messages, author information, and other details are displayed. Users can define their own format strings using various placeholders and formatting directives to extract specific information from Git logs. This feature is useful for automating data extraction or generating reports in desired formats.'
        full-diff: '[AI] `git log --full-diff` is a Git command used to display the difference between each committed version of a file in full, including deleted lines and added whitespace. It shows the complete diff between every two consecutive commits in a series, providing more detailed information compared to the default `git log` output. This can be helpful when investigating complex changes or understanding the sequence of modifications made to specific files.'
        full-history: '[AI] `git log --full-history` is a Git command used to retrieve the committed history of a repository in detailed format. The `--full-history` option includes every single commit, including those with merged branches or commits that were later rebased. It shows all the parents and the commit message for each commit, providing a more complete view of the project''s history.'
        full-index: '[AI] `git log --full-index` is a Git command that displays the commit logs with the full diff statistics for each commit. It shows the difference between the parent and current version of each file in a commit, providing more detailed information compared to the default output of `git log`. This command can be useful when trying to understand the changes made in multiple commits or investigating complex merge conflicts.'
        function-context: '[AI] `git log --function-context` is a Git command used to display the context of functions or methods surrounding a specific commit. It shows the code snippets before and after the change in the specified number of lines, helping developers understand the impact of a commit on the codebase. The context can be specified using the `--context` or `--function-context` option followed by the number of lines to display. For instance, `git log --function-context=10 <commit>` will show 10 lines of context around the function or method that contains the change in the commit.'
        glob: '[AI] The `git log --glob` command is used to show commits that match a given glob pattern in the commit messages. It filters the output of `git log` based on the specified pattern. For instance, `git log --glob="*feature*" --all` will display commits with message containing the string "feature" anywhere. This can be helpful when searching for specific topics of commits across multiple branches.'
        graph: '[AI] `git log --graph` is a Git command that generates an ASCII representation of the project''s commit history as a graph. This graph displays the commits in a tree structure, illustrating their parent-child relationships. The branches are shown as horizontal lines with their corresponding labels. It provides a clear and concise way to visualize the commit history, making it easier to understand the project''s evolution and relationships between different commits.'
        grep: '[AI] `git log --grep` is a Git command used to find specific text within the commit messages in a repository''s history. It searches for the given text pattern using a regular expression and returns the commits that contain the matching message. The output includes the commit hash, author, date, and message, with only the commits containing the search term displayed by default. This command is useful for quickly finding commits related to a specific topic or bug fix.'
        grep-reflog: '[AI] `git log --grep-reflog` is a Git command used to search for commits with messages containing a specified text in reflog messages, not just regular commit messages. Reflogs record deleted and lost commits, so this command can help find old commits that might have been accidentally deleted or lost during a git push failure. The `--grep-reflog` option filters the search in reflog messages using a given regex pattern.'
        histogram: '[AI] `git log --histogram` is a Git command that generates a text-based histogram representation of the committed changes in the current repository, grouped by author or by commit type (e.g., merge commits). Each line in the output represents a unique commit with its corresponding number of commits, displayed as the height of the bar in the histogram. The histogram helps visualize the commit activity trends over time and is particularly useful for identifying periods of intense development or when investigating the distribution of work among team members.'
        ignore-all-space: '[AI] The `git log --ignore-all-space` command is used to display the commit history in Git while ignoring any differences caused by whitespace characters. It''s particularly helpful when dealing with files containing large amounts of whitespace or formatting changes that do not affect the functionality of the code. This option ensures that the focus remains on the actual content changes between commits.'
        ignore-blank-lines: '[AI] `git log --ignore-blank-lines` is a Git command that displays the commit history with blank lines between each commit message ignored. It''s useful when you want to see only the commit messages without the empty lines that might appear due to multiple commits being made in one text editor session or using tools like `git mergetool`. This command helps in having a cleaner and more readable output.'
        ignore-cr-at-eol: '[AI] The `git log --ignore-commit-create-eol` command is used to display the commit message history in Git, but it specifically ignores commits that only modify the commit message at the end of a line (also known as "commit message rebase" or "cr" commits). This option can be useful when you want to focus on the actual changes made in each commit and not the commit messages themselves. By ignoring such commits, the output becomes cleaner and more focused on the substantive differences between commits.'
        ignore-matching-lines: '[AI] The `git log --ignore-matching-lines` command is used to filter out specific lines in the commit messages when displaying the commit history in Git. The `--ignore-matching-lines` option takes a regular expression as an argument, and commits with message lines containing that pattern will be excluded from the output. This can be helpful for ignoring noisy or irrelevant messages in the commit history.'
        ignore-missing: '[AI] `git log --ignore-missing` is a Git command used to show the commit history with missing or moved branches or commits. By default, Git refuses to show commits that are not reachable from any branch and marks them as "missing" or "moved". With the `--ignore-missing` option, Git will display those commits in the log output as if they were part of the branch, even though they are not currently reachable. This can be useful when working with repositories that have complex histories or when merging branches.'
        ignore-space-at-eol: '[AI] The `git log --ignore-space-at-eol` command is used to display the commit history with ignoring white spaces at the end of lines (EOL). This is especially useful when dealing with files that may have different text editors or formatting styles, ensuring a consistent view of the commit messages.'
        ignore-space-change: '[AI] `git log --ignore-space-change` is a Git command used to display the commit history with ignored whitespace changes. The `--ignore-space-at-eol` option can also be used together with it. These options help in focusing on the actual content of the commits and filter out insignificant changes due to added or removed trailing whitespaces, enabling a more meaningful review of the commit history.'
        ignore-submodules: '[AI] The `git log --ignore-submodules` command is used to display the commit history of a Git repository without showing commits related to submodules. Submodules are Git repositories stored as subdirectories in your project, which can be managed independently from the main project. If you want to focus only on the changes made to the main project and ignore the submodule commits, use this command.'
        indent-heuristic: '[AI] `git log --indent-heuristic` is a Git command used to show the commit history with automatic indentation adjustments for better readability. The option `--indent-heuristic` enables Git''s heuristic algorithm to automatically infer the proper indentation level based on the surrounding commits in the output. This makes the log output easier to parse, especially when dealing with deeply nested commits or long commit messages.'
        inter-hunk-context: '[AI] `git log --inter-hunk-context` is a command in Git that displays the context of each hunk, or change set, between two commit messages in a commit history. The context includes the lines of code that were added or removed by each hunk. By default, `git log` shows only the commit messages and the files affected by each commit. However, with the `--inter-hunk-context` option, Git will display the context of every hunk in between two commits, making it easier to understand the changes made in more complex commits.'
        invert-grep: '[AI] The `git log --invert-grep` command is used to find commits that do not contain a specific string in their commit messages. This is essentially the inverse operation of a standard `git grep` or `git log --grep` search. By using the `--invert-grep` option, Git will return commits that do not match the given search term instead of those that do.'
        irreversible-delete: '[AI] `git log --irreversible-delete` is a Git command that displays commits that irreversibly delete files or directories, meaning commits that do not create new files but only remove existing ones. It''s a useful command when you want to find out who deleted specific files or track the history of deletions in your repository. The output shows each commit with its SHA-1 hash, author, date, and message.'
        ita-invisible-in-index: |-
            [AI] The `git log --interval-since=<duration>` command shows commits that were committed within a specified duration. The option `--ita-invisible-in-index` is an extended Git attribute not recognized by default in Git. It's used to include commits with modifications that are not present in the index but still affect the commit message or author date, making them "invisible" in the index.

            So, `git log --ita-invisible-in-index --interval-since=<duration>` shows commits that were committed within a specified duration and have modifications in their commit messages or author dates which are not present in the index.
        l: '[AI] `git log -l` is a Git command that displays the list of commits in the current branch with their corresponding commit messages. The `-l` option stands for "short" and it shows each commit message in a single line format. This command provides an overview of the recent changes made to the repository, allowing users to easily track the project''s history.'
        left-only: '[AI] The `git log --left-only` command displays only the commit messages from the current branch that are not present in the specified committing history. In other words, it shows the differences between the current branch and another branch or commit, highlighting the unique commit messages in the current branch.'
        left-right: '[AI] The `git log --left-right` command displays a unified diff of the differences between two branches or commits in Git. It shows the changes that were made in one branch and not in another, allowing you to easily compare and understand the differences between them. The output is arranged with the common context on the left and the added/removed lines on the right for each hunk.'
        line-prefix: '[AI] `git log --line-prefix` is a Git command used to display commit messages with a custom prefix added to each line. The prefix is specified as an argument to the command. For example, `--line-prefix="[MY_PREFIX]: "` would add "[MY_PREFIX]: " at the beginning of each line in the commit message when displayed. This can be useful for quickly identifying commits based on their messages or for generating reports with specific formatting requirements.'
        log-size: '[AI] The `git log --log-size` command is used to display the commit history with the size of each commit message shown next to it. This can be useful for identifying large commit messages that may need to be split into smaller, more manageable commits to keep a repository''s history clean and easy to navigate. The output includes the commit hash, author information, message, and the size of the message in bytes.'
        mailmap: '[AI] `git log --mailmap` is a Git command used to display commit messages with email addresses in the "from:" format, making it easier to identify the authors of each commit by their emails instead of just their Git username or commit hash. This can be helpful when working on large projects with multiple contributors or when collaborating across teams.'
        max-count: '[AI] `git log --max-count` is a Git command used to display the most recent `N` commit messages in a given branch or commit range. The number `N` is specified as an argument to the `--max-count` option. This can be useful for quickly reviewing the changes made during a specific time period or in a particular sequence of commits without having to scroll through the entire log history.'
        max-parents: '[AI] `git log --max-parents=n` is a Git command that displays the commit history with only the commits reaching up to the specified number of parents (default is 2). In other words, it shows the committed ancestors up to the given level in the merge tree. This can be useful when dealing with complex merge histories or when trying to trace down the origin of a particular branch.'
        merge: '[AI] The `git log --merge` command is used to show the commit history with merge commits only. Merge commits are created when you integrate changes from one branch into another using a three-way merge or fast-forward merge in Git. This command can help you identify and review merge commits specifically, which can be useful for understanding how different branches have been merged together over time.'
        merges: '[AI] `git log --merges` is a Git command that displays the commit history with only the commits that resulted from a merge commit. Merge commits represent the point where two or more branches were merged together in Git. By using this command, you can easily trace the merging activity within your project and understand how different branches have been integrated with each other.'
        min-parents: '[AI] The `git log --min-parents=n` command is used to show commits in the current branch that have at least `n` parent commons. In other words, it filters out commits that are not part of the last `n` branches in the commit history. This can be useful for finding merge commits or to limit the output of log commands to a specific set of branches. For example, `git log --min-parents=2` will only show commits that have at least two parents, which is typically the case for merge commits.'
        minimal: '[AI] `git log --minimal` is a Git command that returns only the commit messages and the abbreviated hash identifiers of the commits, with no other extraneous output such as author information or commit timestamps. It''s useful for generating lists of commit messages for scripting or automation purposes.'
        name-only: '[AI] The `git log --name-only` command is used to display a list of files that have been modified in each commit, with one file name per line. It''s a convenient way to quickly identify which files were changed between specific commits in a Git repository. This command does not display any other information such as commit messages or author details, making it ideal for analyzing file history without excessive output.'
        name-status: '[AI] `git log --name-status` is a Git command used to display the commit history with information about modified, added, or deleted files for each commit. It shows the name of the branch or tag followed by the committer''s name and email, the commit message, and the list of affected files in the format: `M <file>: modified | A <file>: new | D <file>: deleted`. This information allows you to easily understand which files were changed between commits.'
        no-abbrev-commit: '[AI] `git log --no-abbrev-commit` is a Git command that displays the commit history with full commit hashes instead of abbreviated hashes. The `--no-abbrev-commit` option prevents Git from using only the first 7 characters (by default) of a commit hash to represent it, showing the entire 40-character hash instead. This can be useful for identifying commits unambiguously or comparing commit hashes in scripts and other automated processes.'
        no-color: '[AI] `git log --no-color` is a Git command that retrieves the commit history with minimal formatting. The `--no-color` option disables colored output, making it monochrome or plain text. This can be useful for viewing logs in environments where color is not supported or preferred, such as scripts or terminal sessions with limited capabilities.'
        no-color-moved: '[AI] The `git log --no-color` command displays the commit history with minimal formatting, making it suitable for scripts and terminal outputs where color is not desired. The `--no-color-moved` option further removes the colored marks indicating moved or renamed commits when viewing a series of related commits, such as those that result from a rebase or merge operation. This can make the output more consistent and easier to parse in automated workflows.'
        no-color-moved-ws: '[AI] `git log --no-color-moved-ws` is a Git command that displays the commit history with plain text messages instead of colored ones. The `--no-color` option suppresses colored output, but `--no-color-moved-ws` specifically disables the moving of the last column (white space) when a message wraps to the next line. This can be useful for parsing log messages programmatically or in scripts where exact column positions matter.'
        no-decorate: '[AI] `git log --no-decorate` is a Git command used to display commit logs in a plain text format without any branch or tag labels (decorations). This means that only the raw commit hash, author, date, and message are displayed, without any reference to which branch or tag each commit belongs to. It''s useful when you want to see the commits in their most basic form, without any extra information from branches or tags.'
        no-diff-merges: '[AI] The `git log --no-diff-merges` command displays the commit history of a Git repository without showing the diff output for merge commits. Merge commits combine changes from multiple branches into one commit, and their diff output can be complex and difficult to read when using the `--log` command with the default setting. The `--no-diff-merges` option suppresses these merge commits'' diff outputs, showing only their metadata, such as author information, commit message, and parent commits. This command is useful for examining the sequence of non-merge commits in a repository without being distracted by merge commit diff output.'
        no-expand-tabs: '[AI] The `git log --no-expand-tabs` command is used to display the commit history in Git with raw tab characters instead of expanding them into spaces. This option is useful when reviewing commit messages that contain tabs for indentation, ensuring that the original formatting is preserved during the log output.'
        no-ext-diff: '[AI] `git log --no-ext-diff` is a Git command used to display the commit history with minimal diff output. The `--no-ext-diff` option disables the external diff driver, meaning only the default patch format will be shown in the terminal instead of an external diff tool. This can be useful when working with large or multiple files changes and prefer to review the differences in a more concise way within the Git command output.'
        no-indent-heuristic: '[AI] `git log --no-indent-heuristic` is a Git command that retrieves the commit history with minimal formatting applied to the commit messages. The `--no-indent-heuristic` option disables Git''s heuristic attempt to automatically remove indentation from the commit messages when it believes they are indented incorrectly, allowing you to see any leading whitespace in the message exactly as written. This can be useful for dealing with inconsistently formatted messages or when working with non-standard message formatting.'
        no-mailmap: '[AI] `git log --no-mailmap` is a Git command that displays the commit history with raw email addresses instead of the aliases defined in the `git-config mailmap.file` or `user.email` settings. The `--no-mailmap` option disables the email address rewriting feature, ensuring that the exact original email addresses are displayed.'
        no-max-parents: '[AI] The `git log --no-max-parents` command is used to display the commit history of a repository, but it will not show commits that have more than one parent commit (also known as merge commits). This means that only the direct ancestors of the commits being displayed will be shown. This can be useful when trying to trace down the lineage of changes in a project without dealing with the complexities of merge commits.'
        no-merges: '[AI] `git log --no-merges` is a Git command that shows the commit history with only the root commits of each branch or commit tree. It means that merges commits, where multiple branches have been merged together, will not be displayed in the output. This command is often used to focus on the main development lines within a project and ignore any merge commits between them.'
        no-min-parents: '[AI] The `git log --no-merges` command displays the commit history with only non-merge commits. In contrast, `git log --no-min-parents` shows commits that have more than one parent (also known as "multi-parent" or "non-fast-forward" commits). This command is useful when working on topics branches, merges, or other complex branching scenarios. It allows you to explore the commit history with a finer level of detail.'
        no-notes: '[AI] `git log --no-notes` is a Git command that displays the commit history in a raw format, without showing the commit messages. The `--no-notes` option suppresses the output of commit messages, allowing you to focus on the commit hashes, author information, and other metadata.'
        no-patch: '[AI] The `git log --no-patch` command displays the commit messages and metadata of the commits in a given repository, but it does not show the diff patches between each commit. This can be useful when you want to quickly review the commit history without seeing the changes made in each commit.'
        no-prefix: '[AI] The `git log --no-prefix` command displays the commit messages in a Git repository, but without the prefixes that typically include the commit hash, author date, and other metadata. This can make the output cleaner and easier to read when focusing only on the messages themselves.'
        no-relative: '[AI] The `git log --no-relative` command displays the commit history with absolute dates and no abbreviated parent references. It does not use relative terminology such as "2 days ago" or "3 commits ago", instead showing the exact date and hash of each parent commitment. This can be useful for understanding the precise order and relationships between commits when dealing with large or complex projects.'
        no-rename-empty: '[AI] The `git log --no-rename-empty` command displays the commit history with a detailed list of changes in each commit, but it disables the automatic merging of empty or renamed commits into their parent commits during the output formatting. This can be useful when investigating complex merge conflicts or maintaining clear commit histories. Empty commits result from forgotten `git add` commands, while renamed commits occur when a file is moved or renamed within a project between commits. By default, Git merges these commits into their parent, potentially obscuring the original commit information. However, using `--no-rename-empty` prevents this merging and preserves each individual commit''s history.'
        no-renames: '[AI] `git log --no-renames` is a Git command used to display the commit history with separate entries for renames instead of showing them as single rename commands. In other words, it treats renames as distinct commits, allowing for clearer and more detailed viewing of the commit history.'
        no-textconv: '[AI] `git log --no-textconv` is a Git command that displays the commit logs without applying any text filtering or conversion (--no-textconv option). It shows each commit''s message, author, and other metadata in raw format, including hash, parent hashes, and dates. This can be useful when dealing with non-ASCII characters or customized formats in the commit messages.'
        no-use-mailmap: '[AI] The `git log --no-use-mailmap` command is used to display commit logs without expanding email addresses that are registered in the Git mailmap file into their corresponding names. With this option, each commit will show its raw email address instead of the configured name and email alias. This can be useful when dealing with a large number of commits or when you want to compare the exact email addresses associated with each commit.'
        no-walk: '[AI] The `git log --no-walk` command is used to retrieve the commit history of a repository, but with a specific limitation: it only follows direct ancestors in the commit graph. In other words, it doesn''t follow the `--follow` or `--max-parents` options that allow traversing multiple parent commits. This can be useful when you want to see exactly what changes were made between two specific commits without considering their common ancestors.'
        not: '[AI] `git log --not` is a Git command used to show commits that are not parents of the current HEAD commit. In other words, it displays commits that introduced new changes not present in the current branch but in some of its ancestors. This can be helpful when investigating conflicts or understanding where specific changes were introduced from alternative branches or forks.'
        notes: '[AI] `git log --notes` is a Git command used to show the commit messages and their corresponding notes or author messages for each commit in the given history. The `--notes` option displays any notes that were added when committing, which are optional free-form text fields. This command can be useful for reviewing the detailed changeset information with attached contextual information.'
        numstat: '[AI] `git log --numstat` is a Git command that provides a summary of file changes for each committed revision in the current branch or commit range. The output displays the number of added and deleted lines for each file, showing the difference between versions at a glance. It''s an efficient alternative to the traditional long-format `git log` output if you''re only interested in the size and count of changes per file.'
        oneline: '[AI] `git log --oneline` is a Git command that displays the commit messages of the committed changes in a condensed format called "short format" or "one-line format". Each commit message is displayed as a single line containing the commit hash, author date, and the first few words of the commit message. This command is useful for quickly reviewing the recent commits and their associated messages without having to open the full commit history.'
        output: '[AI] `git log --output` is a Git command used to produce an output in a specified format, which can be saved as a file or piped to another command. The output shows the commit history with various data such as commit message, author, date, and hash. By default, it displays the last 10 commits. To get all commits use `git log --output=file.txt --all` instead.'
        output-indicator-context: '[AI] `git log --output-indicator-CONTEXT` is a Git command that displays the context of the changes made in each commit, with the context being the diff output for the specified number of lines before and after each committed change. The `--output-indicator` option adds a prefix or suffix to the output for each commit, which in this case is set to "CONTEXT" for clarity. The default output for `git log` is a list of commits with their messages, so adding `--output-indicator-CONTEXT` provides additional contextual information about each commit''s changes.'
        output-indicator-new: '[AI] `git log --output-indentifier-new` is a Git command used to display the commit history with an additional output indicator for newly introduced commits. The `--output-identifier` option allows you to customize how Git displays the identifiers (hashes or tags) for each commit, with `--output-indentifier-new` specifically highlighting new commits that don''t have any common ancestors with the currently checked-out branch or commit. This command can be helpful when working on multiple branches and merging code to visualize which commits are unique to each branch.'
        output-indicator-old: '[AI] The `git log --output-indentifier-old` command is used to display the commit history with an indicator (a label or symbol) for each old, non-fast-forward commits in the given branch or set of commits. This can be helpful when merging branches or comparing different versions of a project. By default, Git does not indicate old commits differently from new ones, but this option allows you to easily distinguish between them.'
        parents: '[AI] `git log --parents` is a Git command used to display the commit history with the parent commits included. Each commit shows its SHA, author, and message, along with the SHA''s of the parent commits that led to this commit. This command helps in understanding the lineage and relationships between commits in a project.'
        patch: '[AI] `git log --patch` is a Git command used to display the difference between each commit in a given log sequence, allowing for an interactive review of the changes made with every commit. When you run this command, Git displays the patch (difference) between the parent and current commit for each revision, enabling users to inspect and apply individual hunks of code changes interactively before fully committing them. This is useful for reviewing complex or large changes in a more granular way.'
        patch-with-raw: '[AI] `git log --patch-with-raw` is a Git command used to view the difference between the commit and its parent in a raw format during a git log output. The raw patch format (also known as "unified-diff" or "text diff") includes the full context of each hunk, including the header lines with file names, deleted and added lines flags, and context lines before and after the changes. This command is useful when dealing with complex merge conflicts, where you need a more detailed view of the differences between commits to resolve the conflict properly.'
        patch-with-stat: '[AI] `git log --patch-with-stat` is a Git command that displays the commit difference as a unified diff with an added statistic output. The statistic output shows, for each file changed in the commit, the number of additions (+), deletions (-), and modifications (M). This option is useful when you want to see both the detailed differences between commits and a summary of the changes per file at the same time.'
        patience: '[AI] `git log --patience` is a Git command used to display commit history in a more readable way, with commits that share a common ancestor listed vertically instead of being mixed together in the output. This makes it easier to follow the evolution of related changes. The `--patience` option tells Git to format the output using this "patience" style, which groups commits by their common ancestors.'
        perl-regexp: '[AI] `git log --perl-regexp` is a Git command used to filter and display commit messages that match a given Perl regular expression pattern. This command searches through the commit message history of a repository, and only shows commits whose messages match the provided regex. It can be useful for quickly finding and examining commits related to specific topics or issues in a large codebase.'
        pickaxe-all: '[AI] `git log --pickaxe-all` is a Git command used to show the changes made in each commit, along with the files that were modified in those commits. The "--pickaxe-all" option makes Git output the commit message followed by the hunks of changed lines in the affected files. This can be useful for reviewing multiple commits and identifying the specific changes they introduced.'
        pickaxe-regex: '[AI] `git log --pickaxe-regex` is a Git command used to show the commits that introduce a specific regex pattern in file content. The `--pickaxe-regex` option filters commit messages and file changes, allowing users to find commits modifying files with the given regular expression. It displays the diff of the changed lines in each commit. This command is helpful when searching for the history of code modifications across multiple commits.'
        pretty: '[AI] `git log --pretty` is a Git command used to display commit messages in a custom format. The `--pretty` option allows specifying how the output should be formatted using various placeholders like "%h", "%s", "%an" etc., representing hash, subject, author name and so on. This way, you can customize the display of log information to better suit your needs. For example, `git log --pretty="%h %s"` shows each commit with its hash followed by its message.'
        raw: '[AI] `git log --raw` is a Git command used to display the commit messages and raw commit data in plain text format without any additional formatting or filtering. This command shows the actual content of each commit''s tree, parent hashes, and author information, making it useful for parsing commit data with scripts or further processing using other tools.'
        reflog: '[AI] The `git log --reflog` command displays the reflog history in Git. Reflogs are used to recover deleted or lost commits by keeping a record of all created and deleted tags and branch heads. When you run this command, Git will show you a list of recent events related to branches and tags, including deleted branches and tags, with details such as author, commit message, and SHA-1 hash. It''s useful for recovering lost commits or revert unintended changes.'
        regexp-ignore-case: '[AI] `git log --regexp-ignore-case` is a Git command used to filter and display commit messages that match a regular expression pattern, ignoring case differences. The `--regexp-ignore-case` option makes the search case insensitive. This can be helpful when looking for commits with specific keywords or phrases across multiple branches or repositories.'
        relative: '[AI] The `git log --relative` command displays the commit history with each commit''s message and the relative time since the parent commit instead of the absolute date and time. This can be useful when reviewing recent commits in a project to identify more easily which changes were made most recently or within a specific time frame.'
        relative-date: '[AI] `git log --relative-date` is a Git command used to display the commit history with relative time references instead of absolute dates. The `--relative-date` option modifies the output format to show commits as "2 weeks ago", "1 day ago", or similar timeframes relative to the present, making it easier to understand the sequence and age of commits in context.'
        remotes: '[AI] `git log --remotes` displays the commits on all the remote branches that have been pushed to the current repository, but not yet fetched or merged into the local branch. It allows you to see the recent changes made on the remote repositories and compare them with your local repository. This command can help identify conflicts, keep track of remote developments, and facilitate effective collaboration in a Git project.'
        remove-empty: '[AI] The `git log --remove-empty` command displays the commit history with empty commit messages filtered out. Empty commit messages are those that don''t contain any text. This can be useful when you want to focus on the non-trivial commits, as the empty ones may not provide valuable information in understanding the change history.'
        rename-empty: '[AI] The `git log --rename-empty` command is used to display the commit history with renamed files shown as renaming actions instead of deleted and created commits. With this option, empty commits caused by file renames are included in the output, showing the old and new file names side by side. This makes it easier to follow the history of file name changes within a project.'
        reverse: '[AI] `git log --reverse` is a command used in Git version control system to display the commit history with the latest commit appearing first instead of the oldest one. The `--reverse` option changes the order of the commits, allowing you to view the history in reverse chronological order. This can be useful when you want to trace back the changes leading to a specific point in the project''s history or for other specific workflows.'
        right-only: '[AI] `git log --right-only` is a Git command that displays only the most recent commit message and its associated SHA-1 hash, from the current HEAD to the first common ancestor with another branch or commit. In other words, it shows the differences in commit history between two branches or commits, displaying only the changes made on the right side of the fork in the commitment history.'
        rotate-to: |-
            [AI] `git log --rotate` and `--rotate-to` are options used with the Git command `log`. The `--rotate` option is used to iterate over the commit history starting from a specific point, while `--rotate-to` specifies an additional offset to rotate by.

            When you use both options together (`git log <commit> --rotate --rotate-to <offset>`), Git will display the commits reaching back from the specified `<commit>` to the parent of that commit, but it will skip over any commits that have already been shown in the previous rotation. This allows you to iterate through the same set of commits multiple times without repeating them, making it useful when dealing with large or complex Git histories.
        shortstat: '[AI] `git log --shortstat` is a Git command that displays a summarized statistics of the changes made in each commit in the current branch or the one specified. It provides an overview of the number of added and deleted lines per file in each commit, making it helpful for quickly identifying the impact of each commit on your project''s codebase. The output is typically displayed in a tabular format, with columns representing the files, added lines, deleted lines, and total net change.'
        show-linear-break: '[AI] The `git log --show-linear-break` command displays the commit history in a linear fashion, with clearly marked points where lines of development merge or diverge. This can be useful for visualizing complex merges or rebase conflicts. Each breakpoint is indicated by an asterisk (*) and an arrow pointing to the commit that caused the break. The parent commits leading up to the break are displayed in normal format.'
        show-pulls: '[AI] `git log --show-pulls` is a Git command used to display commit messages and the related pull requests they were merged from. It provides an overview of the merge history in a Git repository, making it useful for understanding the origin of merges and tracking the progress of ongoing development efforts. This command does not require any additional arguments beyond `git log`, but you may want to specify a branch or commit range with a prefix like `git log <commit-range> --show-pulls`.'
        show-signature: '[AI] `git log --show-signature` is a Git command that displays the commit logs with an added verification feature called "signatures." Signatures are used to ensure the authenticity and integrity of commits by adding a digital signature. This command shows the commit message, author, timestamp, and the corresponding signature information for each commit. It''s useful in verifying the validity of a commit chain or maintaining a secure Git workflow.'
        simplify-by-decoration: '[AI] `git log --simplify-by-decoration` is a Git command that simplifies the output of a git log by replacing repeated commit messages with their branch names as decorators. This means that when multiple commits share the same message and belong to different branches, only the branch names will be displayed instead of the redundant commit messages in the log output. It makes the output cleaner and easier to follow especially when working on multiple branches at once.'
        simplify-merges: '[AI] `git log --simplify-merges` is a Git command used to display the commit history with merged branches simplified. Merged commits are replaced by their most recent common ancestor, showing only the topmost merge commit in the resulting output. This can make the commit history more concise and easier to read when dealing with complex merging scenarios.'
        since: '[AI] The `git log --since` command displays the commit history of a Git repository, showing only the commits that were made after a specified date or time. The date can be provided in various formats such as "3 days ago", "2021-08-15", or "16:30:00". This command is useful for viewing recent changes and can help with debugging, feature branch management, and other Git workflows.'
        single-worktree: '[AI] `git log --single-worktree` is a Git command used to display the commit history of a repository with the constraint that only the changes made in the current work tree are shown. In other words, it filters the output to include only commits that introduce changes in the files under the current working directory, excluding commits that introduced changes in unrelated or detached branches. This command is particularly useful when you want to examine the history of the project''s main branch while having a local modification, ensuring that your focus remains on the contextually relevant changes.'
        skip: |-
            [AI] The `git log` command with the `--skip` option is used to skip a certain number of parent commits in the output when displaying the commit history. This can be useful for focusing on more recent commits or specific branches in the repository.

            The syntax for using this option is: `git log [<commit>] --skip=[<num>]`

            For example, `git log HEAD --skip=3` would display the commit history starting from the current head commit, skipping the previous three commits and their corresponding messages.
        skip-to: '[AI] `git log --skip-to` is a Git command used to show commits starting from a specified commit, skipping over all the commits that come before it in the commit history. The number following `--skip-to` specifies how many commits to skip. For example, `git log --skip-to=3` will show the last three commits in the branch or commit history.'
        source: '[AI] `git log --source` is a Git command used to display the commit history with the related source code changes for each commit. It shows the difference between the parent and current version of a file in the commit, making it easier to understand the changes made during the development process. This command can help in code reviews or debugging by providing context about the modifications in a more compact and readable way than traditional `git log` output.'
        sparse: '[AI] `git log --sparse` is a Git command that returns the commit history in a sparse format. With this option, only specific files or directories specified using a Gitignore-style pattern will have their commit messages and other related data displayed. This can be useful when working with large repositories where only a subset of files are needed for the current task. The output is similar to the regular `git log` command but only includes the commits that affected the specified files or directories.'
        src-prefix: '[AI] `git log --src-prefix` is a Git command that displays the commit history with an additional prefix in the output. The `--src-prefix` option specifies a string to be added as a prefix before each commit message or tree object name in the output. This can be useful for scripts or automated processes that need to parse the commit log, making it easier to distinguish between different commits or branches in the output.'
        stat: '[AI] `git log --stat` is a Git command that provides a statistical summary of changes made in each commit in the current branch or committed history. It shows the number of added and deleted files, as well as the total number of added and deleted lines for each file. The output is displayed in a tabular format with columns for the author, committer date, and statistics on the number of added and deleted files and lines. This command helps to understand the impact of individual commits on the repository in terms of file changes.'
        stdin: '[AI] `git log --stdin` is a Git command that takes input from a file or standard input stream instead of a commit message when creating a new commit. This can be useful in automated workflows where commits are being generated programmatically, such as in continuous integration systems or scripted workflows. The `--stdin` option tells Git to read the commit message and other commit data from the standard input instead of from a file or interactive prompts.'
        submodule: '[AI] `git log --submodule` is a Git command that displays the commit history of all submodules in the current Git repository. When you use Git to manage projects with subrepositories or subprojects (now referred to as submodules), this command allows you to view the individual commit histories for each submodule, just like you would for the main project. It provides useful information such as the author, message, and commit hash for each submodule''s change. This can be helpful in understanding the history of your project, including when and why specific changes were made in the submodules.'
        summary: '[AI] `git log --summary` is a Git command that displays a summarized version of the commit messages for each committed change in the current branch or the specified range. It provides an overview of the changes made in each commit, including the author, date, and a short description of the changes. This command is useful when you want to quickly review the recent commits without digging into the detailed commit messages or file changes.'
        t: '[AI] The `git log` command with the `-t` or `--topographic` option displays a topographic view of committed history in Git. This representation shows the parent-child relationships between commits, revealing the branching and merging activities in the project timeline. It is particularly useful for understanding complex merge histories or visualizing long-running branches.'
        tags: '[AI] The `git log --tags` command is used to display the commit history with only the tags in the repository. Tags are labels or markers for specific commits, often used for versioning. This command allows you to see when each tag was created and the associated commit hash. It''s helpful for tracking the release history of a project.'
        text: '[AI] `git log --text` is a Git command used to display the commit messages of selected commits in plain text format. It shows each commit''s message, author, and date without any extra formatting or summary information. It''s often used when you want to quickly view the messages associated with specific commits.'
        textconv: '[AI] `git log --textconv` is a Git command that displays the commit messages and applies a specified text conversion on the content of each committed file. The text conversion can be specified using various options, such as a script or an external program. This command is useful when dealing with large binary files and wanting to review the changes made in a more human-readable format.'
        topo-order: '[AI] `git log --topo-order` is a Git command that displays commit history in the linearized topological order, which is the order of commits as they appear in the mainline branch. This means that the parent-child relationships between commits are preserved, and the output shows each commit with its message and author information. This option is particularly useful when dealing with complex branching histories to better understand the causality and dependencies between commits.'
        unified: '[AI] `git log --unified` is a Git command that displays the commit history in a unified diff format. In this format, each commit''s changes are presented as a single, atomic difference between the two parent commits or the initial tree state, if applicable. This can make it easier to review multiple commits and understand the sequence of changes made to a project. Additionally, it is often used in conjunction with `git mergetool` for resolving merge conflicts.'
        until: '[AI] `git log --until` is a Git command used to show commits reaching up to, but not including, a specified reference point in time. The `--until` option takes a date or a relative time string as an argument, and Git will display the commit history with the most recent commit having a tree or parent that is older than the given date or time. This command can be useful when you want to inspect the recent changes before a particular point in time.'
        use-mailmap: '[AI] `git log --use-mailmap` is a Git command used to display commit logs with email addresses resolved to their associated names, if they are configured in the `user.mail` and `user.name` settings or in a `.mailmap` file. This command can be helpful when working on projects with multiple developers who use the same email address, allowing for easier identification of individual commits.'
        walk-reflogs: '[AI] `git log --walk-reflogs` is a Git command used to trace the history of a branch or commit with a focus on following the reflog (short for reference log), which records deleted and forced updates to branches and commits. It displays detailed information about each commit, including author, message, parent commits, and the refs that point to each commit. This command is particularly useful when you need to recover lost commits or revert accidental changes in a Git repository.'
        word-diff: '[AI] `git log --word-diff` is a Git command used to display the difference between the commits in the current branch and its ancestors, showing only the changed words instead of the whole lines or files. This can be useful when you want to focus on specific changes made to particular parts of the code without having to navigate through multiple files. The `--word-diff` option enables this feature by highlighting changed words with a context of surrounding unchanged words, making it easier to identify and understand the precise modifications.'
        word-diff-regex: '[AI] `git log --word-diff-regex` is a Git command used to display the difference between the commits in a more readable way, focusing on changes made to specific words or regex patterns in the commit messages. The `--word-diff-regex` option enables Git to use regular expressions when highlighting changed words, allowing for more precise identification of modified content within the commit messages.'
        ws-error-highlight: '[AI] `git log --ws-error-highlight` is a Git command used to display commit logs with errors related to merge conflicts in the branch history. The `--ws-error-highlight` option enables Git to highlight those commits with an asterisk (*) symbol in the output, making it easier for users to identify and resolve merge conflicts before continuing with their work.'
        z: '[AI] The `git log` command with the `-z` option is used to output the committed message(s) in a zero-delimited format, which is suitable for passing the output directly to other Unix utilities like `awk`, `sed`, and `sort`. It''s often used when you want to perform complex filtering or transformations on the commit messages without having to write an intermediate file.'
