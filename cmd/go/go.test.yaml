# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: test
description: test packages
flags:
    -C=: Change to dir before running the command
    -bench=: Run only those benchmarks matching a regular expression
    -benchmem: Print memory allocation statistics for benchmarks
    -benchtime=: Run enough iterations of each benchmark to take t
    -blockprofile=: Write a goroutine blocking profile to the specified file when all tests are complete
    -blockprofilerate=: Control the detail provided in goroutine blocking profiles by calling runtime.SetBlockProfileRate with n
    -count=: Run each test, benchmark, and fuzz seed n times
    -cover: Enable coverage analysis
    -covermode=: Set the mode for coverage analysis for the package[s] being tested
    -coverpkg=: Apply coverage analysis in each test to packages matching the patterns
    -coverprofile=: Write a coverage profile to the file after all tests have passed
    -cpu=: Specify a list of GOMAXPROCS values for which the tests, benchmarks or fuzz tests should be executed
    -cpuprofile=: Write a CPU profile to the specified file before exiting
    -failfast: Do not start new tests after the first test failure.
    -fullpath: Show full file names in the error messages
    -fuzz=: Run the fuzz test matching the regular expression
    -fuzzminimizetime=: Run enough iterations of the fuzz target during each minimization attempt to take t
    -fuzztime=: Run enough iterations of the fuzz target during fuzzing to take t
    -json: Log verbose output and test results in JSON
    -list=: List tests, benchmarks, fuzz tests, or examples matching the regular expression
    -memprofile=: Write an allocation profile to the file after all tests have passed
    -memprofilerate=: Enable more precise (and expensive) memory allocation profiles by setting runtime.MemProfileRate
    -mutexprofile=: Write a mutex contention profile to the specified file when all tests are complete
    -mutexprofilefraction=: Sample 1 in n stack traces of goroutines holding a contended mutex
    -outputdir=: Place output files from profiling in the specified directory
    -parallel=: Allow parallel execution of test functions
    -run=: Run only those tests, examples, and fuzz tests matching the regular expression
    -short: Tell long-running tests to shorten their run time
    -shuffle=: Randomize the execution order of tests and benchmarks
    -skip=: Run only those tests, examples, fuzz tests, and benchmarks that do not match the regular expression
    -timeout=: If a test binary runs longer than duration d, panic
    -trace=: Write an execution trace to the specified file before exiting
    -v: 'Verbose output: log all tests as they are run'
    -vet=: Configure the invocation of "go vet" during "go test" to use the comma-separated list of vet checks
documentation:
    command: '[AI] `go test` is a command-line tool used in Go programming language for running tests associated with source files in the current directory or specified as arguments. It automatically detects and runs tests written using Go''s testing framework, which includes both unit tests and integration tests. The output displays the test results, including any errors or failures.'
    flag:
        C: '[AI] The `go test` command is used to run Go tests within a project. The `-C` flag (short for `--cover`) enables and saves test coverage data using the `cover` tool in Go. Test coverage measures which parts of the code are executed during testing, providing insights into which areas need more attention. By analyzing the generated report, developers can identify undertested code and improve overall code quality.'
        bench: '[AI] `go test -bench` is a command used in Go programming language to run benchmarks for Go source files. Benchmarks are tests that measure the performance of Go code by running it multiple times with various input sizes and reporting statistics such as the number of operations per second, memory usage, and allocations. This command discovers, runs, and reports on all the benchmarks defined in the source files under test in your current directory.'
        benchmem: '[AI] `go test -benchmem` is a command used in Go programming language to run benchmark tests. Benchmarks are tests that measure the performance of Go code by running it multiple times under controlled conditions and reporting statistics like the number of operations per second. The `-benchmem` flag enables memory profiling during benchmarking, which provides additional information about memory usage patterns in the tested code.'
        benchtime: '[AI] The `go test` command with the `-benchtime` flag is used to run and report the performance benchmarks of Go source files. When you execute `go test -bench .`, it runs all tests in the current directory, but also includes running any defined benchmarks. The output displays the name of each benchmark, the number of times it was run, the duration it took to complete, and other relevant statistics such as allocs, bytes read/written, and GC data. This flag helps developers optimize their code by identifying performance bottlenecks.'
        blockprofile: '[AI] `go test -blockprofile` is a command-line tool in Go programming language used for profiling specific blocks of code during testing. It generates a blocking profile file, which records the duration and call stack information for each function call that blocks the execution of goroutines, i.e., functions causing long-running synchronous tasks or acquiring locks. The obtained data can be further analyzed using tools like Go''s `pprof` or external visualization tools to identify bottlenecks and optimize the code in those problematic areas.'
        blockprofilerate: '[AI] The `go test` command with the `-blockprofile` flag is used for profiling Go code during testing. When this flag is set, the Go testing tool executes the test cases multiple times under different input data and records detailed CPU profile information for each test function execution block. This information can help identify performance bottlenecks in your code by providing insights into which parts of the code are taking up the most time to execute. The generated profiling results can be further analyzed using various tools like `pprof` or visualization libraries such as `gographviz`.'
        count: '[AI] `go test` is a command-line tool used in Go programming language for testing source code. The `-count` option is an argument that can be passed to this command. It controls how many tests are run in each parallel test goroutine. By default, `go test` runs tests in all available goroutines, which may depend on the number of CPUs. Specifying a positive integer with `-count` limits the number of goroutines, which can be useful for limiting test resource usage or isolating test interference.'
        cover: '[AI] `go test` is a command-line tool in Go programming language for running tests within a Go project. The `-cover` flag is an option that enables and outputs coverage information during testing. Coverage information includes details about which parts of the source code were executed during the test run, providing insights into untested areas and helping to ensure comprehensive test coverage.'
        covermode: |-
            [AI] `go test` is a command-line tool used to run tests in Go language projects. The `-covermode` option specifies how code coverage data should be computed and reported during testing.

            There are four available cover modes:

            1. `atomic`: Only computes the coverage of individual tests, not the entire test suite. This is the fastest mode.
            2. `count`: Similar to atomic but reports the total number of times each source code line was executed as part of test coverage results.
            3. `profile`: Computes and writes detailed profile data for later analysis using the `pprof` tool. It provides per-function call graph, per-branch execution count, etc., which can help identify hotspots. This mode is slower than others.
            4. `none`: Disables code coverage computation and reporting.

            When you use `go test -covermode <mode>`, replace `<mode>` with one of the above modes to configure the testing and coverage analysis according to your requirements.
        coverpkg: '[AI] `go test -coverpkg` is a command used in Go programming language to generate test coverage reports. When executed, it runs all tests in the current directory or specified package, and produces a summary of which source code lines were executed during testing. The output includes the percentage of covered lines and branches for each tested file, helping developers identify and improve the code areas with low coverage.'
        coverprofile: '[AI] `go test -coverprofile` is a command used in Go programming language to generate a coverage profile during testing. The `-coverprofile` flag specifies an output file where the generated coverage data will be stored. This data can later be visualized using tools like `gcov`, `llcov`, or other third-party libraries, providing insights into which parts of your code were executed during testing and which were not. It helps in identifying untested lines and functions, improving test suite effectiveness and ensuring better code coverage.'
        cpu: '[AI] The `go test` command is a built-in tool in Go language used to run tests for Go projects. The `-cpu` flag is an optional argument that can be passed with this command. This flag instructs the testing tool to use only one CPU core while running tests, which can be helpful when running tests on systems with multiple cores or processors, ensuring that each test runs sequentially and avoiding possible interference or contention between concurrent tests. However, using fewer CPU cores may increase the overall test execution time.'
        cpuprofile: '[AI] `go test -cpuprofile` is a command used in Go programming language to run unit tests with CPU profiling. When executed, the Go testing tool (`go test`) runs the specified tests and generates a CPU profile file in the `.prof` format. This file can be later analyzed using tools like `pprof` or other visualization tools to identify hotspots and optimize performance issues in the code under test.'
        failfast: '[AI] `go test -failfast` is a command used in Go programming language to run tests with the fail-fast mode enabled. In this mode, once a test fails, the testing process will immediately stop running subsequent tests. This can save time and resources by preventing the execution of tests that may not pass due to an earlier failure. It''s useful for quickly identifying issues during development or when running large test suites.'
        fullpath: '[AI] The `go test` command is used to run Go tests within a project. The `-fullpath` flag, when provided, specifies that the test binary should be executed using its full path instead of using the one in the current $GOPATH. This can be useful when running tests in environments where the $GOPATH may not be set correctly or when working with multiple projects that have conflicting dependencies. The full path to the test binary should be provided as an argument, e.g., `go test -fullpath /path/to/test/binary`.'
        fuzz: '[AI] `go test -fuzz` is a command used in Go programming language to run a special type of testing called fuzz testing. Fuzz tests are designed to find edge cases and bugs by feeding random or semi-random data to the program under test (PUT). The `go test` command with the `-fuzz` flag runs all Go source files in the current directory that define fuzz tests, and reports any new failures or unexpected behavior. Fuzz testing is particularly effective for finding issues related to data parsing, data validation, or other parts of the code where handling unexpected inputs is important.'
        fuzzminimizetime: |-
            [AI] `go test -fuzz` is a command used in Go programming language to run the built-in fuzzer testing tool. The `-fuzz` option enables fuzzer testing, which involves feeding random data to the program under test (PUT) and observing its behavior to find potential bugs or vulnerabilities.

            The `-fuzzminimizetime` option is used to limit the total duration of individual test cases during fuzzer testing. It takes a duration value in seconds as an argument. This option helps control the resource consumption of fuzzer tests and can help prevent excessive usage of computing resources or network bandwidth, which can be important in large-scale continuous integration environments.
        fuzztime: '[AI] `go test -fuzz` is a command used in Go programming language to run the built-in fuzz testing tool. It helps find new input cases that cause failures or errors in existing code. `go test -fuzztime`, however, is an extension of the standard `go test -fuzz` command. It runs the fuzz testing with a time limit, which allows controlling the test execution duration and can help identify performance bottlenecks by finding inputs that take longer to process than expected.'
        json: '[AI] `go test -json` is a command used in Go programming language to run tests and output test results in JSON format. This can be useful for automated testing, continuous integration, or data analysis as it provides structured data about the tests executed, including the test name, status (passed or failed), and duration.'
        list: '[AI] `go test -list` is a command used in Go programming language for listing all tests in the current module or directory. It does not run the tests but only displays their names, allowing users to selectively choose which tests they want to execute using other flags or running the tests individually.'
        memprofile: '[AI] `go test -memprofile` is a command used in Go programming language to run tests with memory profiling. When executed, it runs all tests in the current directory or specified by the GOTEST flag, and generates a memory profile file named `pprof.mem` in the current directory for each test. The memory profile data can be later analyzed using tools like `pprof` to identify memory usage patterns and memory leaks in Go applications.'
        memprofilerate: '[AI] `go test` is a command-line tool in Go programming language used to run tests for your codebase. The `-memprofile` flag enables memory profiling during testing. When you run `go test -memprofile`, it produces a memory profile file after each test, showing details about the memory allocation and usage patterns of the tested functions or packages. These profiles can help identify memory leaks and excessive memory allocations for optimization purposes.'
        mutexprofile: '[AI] `go test -mutexprofile` is a command used in Go programming language for profiling mutex contention during testing. It runs tests with the built-in mutex profiling feature enabled and generates a pprof-compatible profile file named `mutex.prof`. This data can be further analyzed using tools like `pprof`, providing insights into where and how frequently mutexes are being contended, which can help improve concurrency and synchronization in the code.'
        mutexprofilefraction: '[AI] `go test -mutexprofilefraction` is a command-line option for Go''s testing tool, `go test`. It generates a mutex profile during testing, which provides information about the locking behavior of Goroutine synchronization primitives like Mutexes and RWMutexes. The `-mutexprofilefraction` flag specifies the fraction of time (as a percentage) to spend on mutex profiling. For example, `go test -test.run=N -mutexprofilefraction 100` spends 100% of testing time on generating mutex profiles. These profiles can help identify contention hotspots in concurrent programs, improving their concurrency and parallelism characteristics.'
        outputdir: '[AI] `go test` is a command-line tool used to run tests in Go programming language. The `-outputdir` option specifies the directory where the test output files, such as test logs and test binaries, will be placed. This flag helps keep the output of multiple tests organized by storing them in a specific directory instead of having them scattered in the working directory.'
        parallel: '[AI] `go test -parallel` is a command used in Go programming language to run tests in parallel. When executed, it will discover, compile, and run tests using multiple CPU cores or processes. This can significantly reduce the total time it takes to run all tests by efficiently utilizing available resources.'
        run: '[AI] `go test -run` is a command used in Go programming language to run only the tests specified in the current file or the one matching a given pattern. The `go test` command discovers, runs and reports on tests within the source files in the current directory. Adding `-run` flag followed by the test name or pattern allows running only those specific tests instead of all tests in the directory. For example, `go test -run TestAddition.test` will execute just the "TestAddition" test case from the file named "test\_addition.go".'
        short: '[AI] The `go test -short` command is a part of Go programming language''s testing framework. It runs only the tests that are directly required to pass before running other tests in the current package or in dependencies. This is useful for quickly checking if a specific change did not introduce any new errors or failures. The `-short` flag reduces the test execution time by skipping tests that do not depend on the modified code.'
        shuffle: '[AI] The `-shuffle` flag in `go test` is used to randomize the order of tests within a test suite during execution. This is helpful for identifying interactions between tests that might not be apparent when they are run in a deterministic order. Randomizing test order can help uncover hidden dependencies, race conditions, and other subtle issues. It''s particularly useful for large test suites or when testing concurrent code.'
        skip: |-
            [AI] The `go test` command is used to run tests in a Go project. The `-skip` flag is an option that allows you to skip running specific tests without modifying the test code itself. This can be useful when you want to run all tests except for one or more, perhaps because they take a long time to run or fail consistently but don't affect the overall functionality of the project.

            When using `go test` with the `-skip` flag, you specify the test files or test functions you wish to skip by prefixing them with an exclamation mark (`!`) in the list of tests provided to the command. For example:

            ```bash
            $ go test . -test.Run "!*some_test.go"
            ```

            This will run all tests under the current directory (`.`) except for those defined in `some_test.go`.
        timeout: '[AI] `go test -timeout` is a command used in Go programming language to run tests with a specified timeout. This option sets a maximum duration for each test function to run before it gets terminated, helping prevent tests from running indefinitely due to bugs or other issues. By default, there''s no timeout set, and the tests run without any time limit. However, you can provide a duration value in seconds (e.g., `-timeout=1s`) or use durations like "5m" for 5 minutes to set a custom timeout. This command ensures that your test suite runs efficiently and effectively, while still allowing long-running tests to be included in the test suite without causing unnecessary delays during development.'
        trace: '[AI] `go test -trace` is a command used in Go programming language for running tests with enhanced debug output. It provides detailed information about the test execution flow, including the order of testing functions and packages, test results (pass or fail), elapsed time per test, and any errors or panics that occur during testing. This level of detail can be helpful for diagnosing issues in complex test suites or for understanding the dependencies between tests.'
        v: '[AI] `go test -v` is a command used in Go programming language to run unit tests with verbose output. The `-v` (or `--verbose`) flag instructs the go test tool to print test names as they are running and report additional information about each test case, such as the time taken and whether it passed or failed. This can help developers better understand which tests are being executed and identify any potential issues with their code.'
        vet: '[AI] `go test -vet` is a command used in Go programming language to run all tests in the current directory or specified package with a special flag `-vet`. This flag enables and runs the static analysis tool `go vet` on the source code files before running the tests. The purpose of using this command is to identify and fix potential errors, inconsistencies, or security vulnerabilities in the codebase, ensuring better code quality.'
