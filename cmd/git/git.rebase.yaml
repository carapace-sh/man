# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: rebase
description: Reapply commits on top of another base tip
group: main
flags:
    --abort: abort and check out the original branch
    --apply: use apply strategies to rebase
    --autosquash: move commits that begin with squash!/fixup! under -i
    --autostash: automatically stash/stash pop before and after
    --committer-date-is-author-date: passed to 'git am'
    --continue: continue
    --edit-todo: edit the todo list during an interactive rebase
    --empty=: how to handle commits that become empty
    --fork-point: use 'merge-base --fork-point' to refine upstream
    --ignore-date: passed to 'git am'
    --ignore-whitespace: passed to 'git am'
    --keep-base: use the merge-base of upstream and branch as the current base
    --no-ff: cherry-pick all commits, even if unchanged
    --no-verify: allow pre-rebase hook to run
    --onto=: rebase onto given branch instead of upstream
    --quit: abort but keep HEAD where it is
    --reapply-cherry-picks: apply all changes, even those already present upstream
    --rerere-autoupdate: update the index with reused conflict resolution if possible
    --reschedule-failed-exec: automatically re-schedule any `exec` that fails
    --root: rebase all reachable commits up to the root(s)
    --show-current-patch: show the patch file being applied or merged
    --signoff: 'add a Signed-off-by: line to each commit'
    --skip: skip current patch and continue
    --whitespace=: passed to 'git apply'
    -C=: passed to 'git apply'
    -S, --gpg-sign?: GPG-sign commits
    -X, --strategy-option=: pass the argument through to the merge strategy
    -f, --force-rebase: cherry-pick all commits, even if unchanged
    -i, --interactive: let the user edit the list of commits to rebase
    -m, --merge: use merging strategies to rebase
    -n, --no-stat: do not show diffstat of what changed upstream
    -q, --quiet: be quiet. implies --no-stat
    -r, --rebase-merges?: try to rebase merges instead of skipping them
    -s, --strategy=: use the given merge strategy
    -v, --verbose: display a diffstat of what changed upstream
    -x, --exec=: add exec lines after each commit of the editable list
documentation:
    command: |-
        [AI] `git rebase` is a Git command used to integrate changes from one branch into another, usually with the intention of keeping the target branch's commit history linear. It does this by applying each commit from the source branch on top of the current branch, creating new commits if necessary. This can help simplify complex histories or resolve conflicts before pushing changes to a shared repository. The basic syntax for using `git rebase` is:

        ```bash
        $ git checkout <desired_branch>
        $ git rebase <source_branch>
        ```

        Replace `<desired_branch>` with the name of the branch you'd like to update, and `<source_branch>` with the name of the branch containing the changes you want to incorporate. Git will then apply each commit from the source branch in sequence, creating a new, cleaner commit history for the target branch.
    flag:
        C: '[AI] `git rebase -C` is a Git command used for interactive rebasing with the "edit mode" enabled for every commit in the rebase sequence. The "C" option stands for "continue" after editing a commit message or making changes in the editor. It''s an advanced command that allows you to edit multiple commits at once, fix mistakes, squash commits, and even change the parentage relationships between them. When used, Git will pause at each commit and open your default text editor for you to make modifications. Once saved, Git will resume the rebasing process with your changes applied.'
        abort: '[AI] `git rebase --abort` is a Git command used to undo an ongoing rebase operation and reset the working directory to its state before starting the rebase. It leaves your local commits unaffected, discards any temporary commits created during the rebase process, and returns you to the point where you initially started the rebase. This is useful when you encounter conflicts or decide that you don''t want to continue with the ongoing rebasing process.'
        apply: '[AI] `git rebase --apply` is a Git command used to apply the changes introduced by a series of commits, usually from a feature branch, onto another branch like master or main. Instead of creating an interactive rebase session where you can squash or edit commits, this command directly applies each commit''s changes one by one on top of the current branch''s tip. This is useful when you want to apply someone else''s work without the need for interactive rebasing and keeping the original commits'' history intact. Remember that applying commits in this way may lead to conflicts if the changes introduce conflicting modifications, and you will have to resolve them manually.'
        autosquash: '[AI] `git rebase --autosquash` is a command used during an interactive rebase session in Git. It automates the process of creating and applying commits that squash (combine) multiple commits into a single commit, preserving author dates and messages. Each squashed commit represents the changes introduced by multiple original commits with similar or identical messages. This command makes rebasing more efficient by reducing the number of interactive prompts during the rebase process.'
        autostash: '[AI] `git rebase --autostash` is a command used in Git version control system to perform an interactive rebase with automatic stashing and applying of stashed changes. When you run this command, Git will first check if there are any local changes or uncommitted files in your current branch. If found, Git will automatically stash these changes using `git stash save` command, and then enter the rebase process. During the rebase, Git applies each commit from the branch you''re rebasing onto one-by-one, allowing you to interactively amend, squash or reorder commits as needed using standard interactive rebase commands. After finishing the rebase process, Git will apply the stashed changes back to your current branch using `git stash apply` command. This command makes it easier for developers to perform a clean and organized rebasing without worrying about local modifications.'
        committer-date-is-author-date: '[AI] `git rebase --committer-date-is-author-date` is a Git command that changes the behavior of the `--rebase` interaction mode. Normally, Git sets the author and committer dates to be the same when creating a new commit during an interactive rebase session. However, this flag overrides that default behavior and sets the committer date to match the author date instead. This can be useful in cases where you want to preserve the original author dates but still modify the commit messages or squash multiple commits into one.'
        continue: '[AI] `git rebase --continue` is a Git command used during an interactive rebase session to continue the rebasing process after resolving merge conflicts between commits. After making the necessary changes to resolve any conflicts, this command is used to tell Git to apply the next commit in the chain of commits being rebased, automatically fast-forwarding the current branch to the new base if no further conflicts are encountered.'
        edit-todo: '[AI] `git rebase --edit-todo` is a Git command used to open an editor with a list of commits that will be applied during a rebase process. The editor allows you to modify commit messages or squash multiple commits into one, helping to keep your commit history clean and concise before creating a new branch or merging changes. This command is especially useful when preparing a pull request or working on complex feature branches.'
        empty: '[AI] `git rebase --empty` is a Git command used to create an empty commit, also known as a "blank commit" or a "placeholder commit." This command does not modify any existing commits; instead, it creates a new commit with no changes in the current branch. The purpose of this command can be useful when preparing for rebasing multiple branches or merging feature branches back to the mainline, allowing you to maintain a clean and consistent commit history.'
        exec: |-
            [AI] `git rebase --exec` is a Git command used to execute custom scripts or commands during the rebasing process. It allows users to specify a shell command that will be run for each commit being rebased, allowing for more advanced rebasing scenarios. The general format of this command is:

            ```bash
            git rebase --exec <command> <branch1> <branch2>
            ```

            Replace `<command>` with the shell command you want to execute, `<branch1>` with the source branch, and `<branch2>` with the target branch. This command should take care of processing the commits from `<branch1>` and applying them onto `<branch2>`. Keep in mind that the use of this command can be complex and may require a good understanding of Git and shell scripting to ensure correct application of the custom commands.
        force-rebase: '[AI] `git rebase --force-rebase` is a Git command used to continue a rebasing session that was previously interrupted or failed. It allows force-continuing an ongoing rebase, which means Git will overwrite any commits that have already been created during the rebasing process with new versions. This can potentially be dangerous if used incorrectly, as it may lead to data loss or conflicts. Therefore, it should be used with caution and only when absolutely necessary.'
        fork-point: |-
            [AI] The `git rebase --fork-point` command is not a standard Git command, as Git does not have a built-in `--fork-point` option for rebasing. This could be a custom command or an alias created in a Git workflow using specific tools like `git-rebase-gui`, designed for managing fork-based workflows in a distributed Git project.

            When used, this command is intended to create a new base branch (a new common ancestor) for two branches that have diverged but need to be rebased on top of each other. It helps resolve merge conflicts and keep the project history linear when working with multiple forks or remote branches. The exact behavior might depend on the specific implementation of this command or alias.
        gpg-sign: '[AI] `git rebase --gpg-sign` is a Git command used to sign the commits created during an interactive rebase session with OpenPGP keys. This command ensures that all commits in the rebase sequence have valid GPG signatures before being applied on top of the target branch. It enhances the security and authenticity of the commits, as each one is verified against its associated private key.'
        ignore-date: |-
            [AI] The `git rebase` command is a powerful tool for applying a series of commits on top of another branch, essentially "replaying" those commits in a new base. The option `--ignore-date` modifies this behavior by telling Git to ignore any date information when finding commits to reapply during a rebase.

            This can be useful when working with commits that have incorrect author or commit dates, but whose changesets are still desired. By ignoring the dates, Git will match and apply the commits based on their hash values and messages instead. Note that using this option may result in inconsistent or confusing commit histories if used carelessly.
        ignore-whitespace: '[AI] `git rebase --ignore-whitespace` is a command used in Git version control system. It modifies the rebasing process to ignore changes in white spaces like tabs and spaces, allowing the rebasing to continue even if there are whitespace differences between branches being merged. This can be useful when merging branches that have different coding styles or prefer consistent formatting. However, it''s important to note that using `--ignore-whitespace` should be done with caution as it may hide potential conflicts and could result in unintended changes.'
        interactive: '[AI] `git rebase --interactive` is a Git command used to interactively rebase one or more branches on top of another branch. It opens up an editor (usually `vim` or `nano`) where you can edit the list of commits in the current branch, allowing you to reorder, squash, or delete them before they are applied as new commits on the target branch. This command is often used for cleaning up messy commit histories or applying multiple commits as a single clean commit. It does not fast-forward the branches but creates a new branch based on the current one.'
        keep-base: '[AI] `git rebase --keep-base` is a Git command used during interactive rebasing to preserve the original commit as a new commit on top of the current base. This command allows keeping the original author, commit message, and other metadata, while continuing the rebasing process. It''s useful when you want to change commits in an ongoing rebase without losing the original history.'
        merge: '[AI] `git rebase --merge` is a Git command used to perform both a git rebase and a git merge in one step, also known as an interactive rebase with merges. It begins by fetching the latest changes from the remote repository, then applies your local commits onto the top of the current branch. If there are any conflicts between the local and remote branches during this process, Git will pause and allow you to resolve them before continuing. Once all conflicts have been resolved, Git will create a new commit for each local commit that includes the merged changes from the remote branch. This command is useful when collaborating on a project where multiple developers are pushing and pulling changes frequently. It helps keep the project''s history linear by combining the effects of both a rebase and a merge into one step.'
        no-ff: '[AI] `git rebase --no-ff` is a command used in Git version control system. It initiates an interactive rebasing session, which applies a series of commits on top of another branch, fast-forwarding the history if there are no conflicting commits. The `--no-ff` option disables the fast-forward mode, ensuring that every commit is replayed as a new "real" commit, creating a linear and more readable history instead of a hidden, lost-history "fast-forward" merge. This is often used when preparing a pull request or contributing to open-source projects.'
        no-stat: '[AI] `git rebase --no-stat` is a command used in Git version control system. It starts an interactive rebase session, but disables the display of a diff stat summary for each commit that is being applied. This can be useful when working on large or complex rebase tasks where the output of the stat summaries can clutter the console and make it harder to focus on the changes being made. Instead of showing the statistics, Git will only show the messages associated with each commit as they are being applied.'
        no-verify: '[AI] `git rebase --no-verify` is a command used in Git version control system. It starts an interactive rebase session similar to `git rebase`, but with the difference that it skips the verification step where Git asks for confirmation before applying each commit. This can be useful when you want to automate or script the rebasing process and don''t need the interactive confirmation prompts. However, using `--no-verify` should be done with caution as it bypasses the safety check that ensures you are really applying the intended commits.'
        onto: |-
            [AI] `git rebase --onto` is a Git command used for advanced rebasing techniques. It allows you to merge or reapply commits from one branch onto another, effectively "reapplying" the changes introduced by those commits on another branch.

            The basic syntax is: `git rebase <source-branch> --onto <destination-branch>`, where:

            * `<source-branch>` is the branch that contains the commits you want to reapply or merge, and
            * `<destination-branch>` is the branch where you want to apply those commits.

            This command works by moving the current branch (the one you're rebasing) onto the specified source branch. The result will be that the last common ancestor commit between the source and destination branches becomes the new base for the current branch, with all the commits from the source branch being applied on top of it in the destination branch.

            In summary, `git rebase --onto` enables advanced rebasing scenarios where you want to apply changes from one branch onto another, allowing you to manipulate commit history more efficiently and precisely.
        quiet: '[AI] `git rebase --quiet` is a Git command used to perform interactive rebasing with minimal output. It allows the rebasing process to run in the background without displaying each commit message or other detailed information at the console. This can be useful when performing multiple rebases in a row or when working on a headless CI/CD system, where the focus is on the successful completion of the rebase rather than observing its progress step by step.'
        quit: '[AI] `git rebase --quit` is a command used in Git version control system to interrupt or abort an ongoing interactive rebase session. When you start an interactive rebase, Git opens up an editor where you can modify the commit history. If you decide that you don''t want to continue with the changes you made in the editor, you can use `git rebase --quit` to exit the rebasing process cleanly without committing any changes. This command tells Git to stop modifying the current branch and leave it in its original state before starting the rebase.'
        reapply-cherry-picks: '[AI] `git rebase --reapply-cherry-picks` is a Git command used to apply cherry-picked commits on top of an ongoing rebasing process. When you''ve already started a rebase, but have applied some commits as cherry-picks outside of the rebase process, this command comes in handy. It retrieves those cherry-pick commits and applies them one by one on top of your current rebase branch. This way, all changes are applied consistently within the rebasing workflow.'
        rebase-merges: '[AI] `git rebase --rebase-merges` is a Git command used to perform an interactive rebase, where each commit that introduces a new branch is split into multiple commits: one commit for creating the new branch and another for introducing the changes to be merged into the target branch. This allows for more control over the merge process in a linear history, avoiding the creation of merge commits unless desired. It''s particularly useful when collaborating on feature branches that need to be cleanly integrated back into the main branch.'
        rerere-autoupdate: |-
            [AI] `git rebase --rerere-autoupdate` is a Git command used to enable the Rerere (Resolved Early Reused REScan) feature in an interactive rebase session with the autoupdate option.

            Rerere is a Git mechanism that saves and reuses previous conflict resolutions for subsequent identical conflicts. It aims to reduce the number of conflict resolutions during a rebase by remembering how similar conflicts were resolved before. With `--rerere-autoupdate`, Git automatically applies these saved solutions when encountering identical conflicts in the same file, without asking for user intervention.

            In summary, this command helps streamline the rebasing process by automating the application of previously resolved conflict resolutions when dealing with identical conflicts.
        reschedule-failed-exec: '[AI] `git rebase --reschedule-failed-exec` is a Git command used during an interactive rebase session to automatically retry failed executable commands in the current or next commit. When a command in a rebase fails, it stops the rebasing process. With this option, Git will attempt to run the failed command again after each conflict resolution without requiring manual intervention to continue the rebase. If the command continues to fail, the rebase process will be aborted.'
        root: '[AI] `git rebase --root` is a Git command used to perform an interactive rebase starting from the root of the current branch, which is typically the commit point where the branch was created from the mainline branch. This command opens up an editor with a list of commits in that branch, allowing users to edit or squash multiple commits into one for a cleaner and more linear commit history. It''s useful when working on a long-lived branch and wanting to tidy up the commit messages or merge smaller changes into larger ones before merging back to the mainline.'
        show-current-patch: '[AI] `git rebase --show-current-patch` is a Git command used during an interactive rebase session. It displays the patch or changes that will be applied next in the current rebase sequence before actually applying them. This command allows you to review and edit the changes before committing them, ensuring that the history remains clean and accurate.'
        signoff: '[AI] `git rebase --signoff` is a command used in Git version control system to complete an interactive rebase session and create or update commit messages. When you start an interactive rebase with commands like `git rebase -i`, it opens an editor with a list of commits for you to edit. After editing the commits, you can use `git rebase --continue` to apply those changes, but if you want to also create or update the commit messages for each commit using your text editor, you can instead use `git rebase --signoff`. This command will open your default text editor to allow you to edit the author and committer messages for each commit, and once saved, it will automatically apply the changes made in the rebasing process.'
        skip: '[AI] `git rebase --skip` is a Git command used during an interactive rebase session to skip over a commit without losing its changes. Instead of applying the commit, this command skips to the next one in the series. It''s useful when you want to bypass certain commits while maintaining the continuity and history of your repository.'
        strategy: '[AI] `git rebase --strategy` is a command used in Git for performing interactive rebases with customized strategies. A strategy is a plugin that defines how Git applies commits during an interactive rebase. The default fast-forward strategy applies if no conflict or changes are detected. However, other strategies like "rebase-merge" or "ours" can be used to handle merge conflicts differently. By using `git rebase --strategy`, you can specify a custom strategy plugin to modify the rebasing process according to your requirements.'
        strategy-option: '[AI] `git rebase` is a command in Git for applying a series of commits on top of another branch. The `--strategy-option` flag is an advanced option that allows specifying strategy-specific options when invoking a custom merge strategy during a rebasing process. This can be used to fine-tune the behavior of specific merging strategies like `rebase-mergetool`, `rebase-interactive`, and others, depending on your use case and requirements. For more information about available strategies and their options, refer to the Git documentation.'
        verbose: '[AI] `git rebase --verbose` is a command used in Git version control system to perform an interactive rebase with more detailed output. This command applies each commit one by one, applying as many as possible without conflicts. If there are any conflicts during the rebasing process, Git will pause and allow you to resolve them before continuing. The `--verbose` option increases the amount of information displayed during the rebasing process, making it useful for understanding the changes being applied in detail.'
        whitespace: '[AI] `git rebase --whitespace` is a command used in Git version control system for interactive rebasing with whitespace cleaning. It applies a series of commits on top of another branch, while automatically fixing any whitespace inconsistencies between the base and current branches. This can help maintain consistent coding styles across projects or teams.'
