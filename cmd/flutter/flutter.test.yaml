# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: test
description: Run Flutter unit tests for the current project
flags:
    --coverage: Whether to collect coverage information.
    --coverage-path=: Where to store coverage information (if coverage is enabled).
    --dart-define*=: Additional key-value pairs that will be available as constants.
    --dds-port=: Dart Development Service (DDS) will be bound to the provided port.
    --device-user=: Identifier number for a user or work profile on Android only.
    --merge-coverage: Whether to merge coverage data with "coverage/lcov.base.info".
    --name=: A regular expression matching substrings of the names of tests to run.
    --no-null-assertions: Do not perform additional null assertions on the boundaries of migrated and un-migrated code.
    --no-pub: Do not run "flutter pub get" before executing this command.
    --no-run-skipped: Do not run skipped tests instead of skipping them.
    --no-test-assets: Do not build the assets bundle for testing.
    --no-track-widget-creation: Do not track widget creation locations.
    --null-assertions: Perform additional null assertions on the boundaries of migrated and un-migrated code.
    --plain-name=: A plain-text substring of the names of tests to run.
    --pub: Run "flutter pub get" before executing this command.
    --run-skipped: Run skipped tests instead of skipping them.
    --shard-index=: Tests can be sharded with the "--total-shards" and "--shard-index" arguments.
    --start-paused: Start in a paused mode and wait for a debugger to connect.
    --test-assets: Build the assets bundle for testing.
    --test-randomize-ordering-seed: The seed to randomize the execution order of test cases within test files.
    --timeout=: The default test timeout, specified either in seconds.
    --total-shards=: Tests can be sharded with the "--total-shards" and "--shard-index" arguments.
    --track-widget-creation: Track widget creation locations.
    --update-goldens: Whether "matchesGoldenFile()" calls within your test methods should update the golden files rather than test for an existing match.
    --web-renderer: The renderer implementation to use when building for the web.
    -h, --help: Print this usage information.
    -j, --concurrency=: The number of concurrent test processes to run.
    -r, --reporter=: Set how to print test results.
    -t, --tags: Run only tests associated with the specified tags.
    -x, --exclude-tags: Run only tests that do not have the specified tags.
documentation:
    command: '[AI] `flutter test` is a command used in Flutter development for executing tests associated with your project. It runs all the tests under the `test` directory, using the Dart test runner to check the correctness of your codebase''s functionality. The output will show passed or failed status along with any error messages for each individual test.'
    flag:
        concurrency: '[AI] `flutter test --concurrency` is a command-line argument used with the Flutter testing framework to run tests concurrently. It specifies the number of parallel test threads to use, allowing for faster test execution time by running multiple tests simultaneously. For example, `flutter test --concurrency=4` would run tests using four parallel threads. This can significantly reduce the overall time it takes to complete a large set of tests.'
        coverage: '[AI] `flutter test --coverage` is a command used in Flutter development for generating test coverage reports. It runs all the tests in your project and produces a detailed analysis of which parts of your code are covered (or not) by those tests. The output is typically displayed in an interactive format using tools like IDEs or coverage reporting tools, helping developers identify untested areas and improve testing coverage for better application reliability and maintainability.'
        coverage-path: '[AI] `flutter test --coverage-path` is a command used in Flutter for running tests with code coverage analysis. It runs all tests under the `test` directory and generates a report showing which parts of the code were executed during the test run. The `--coverage-path` option specifies the file path where the generated HTML coverage reports will be saved, allowing developers to inspect test coverage for their Dart code.'
        dart-define: '[AI] `flutter test --dart-define` is a command used in Flutter for writing tests with custom Dart definitions. The `--dart-define` option allows defining variables or constants that can be accessed by the tested Dart code during the testing phase. This can be useful when testing code that relies on external configuration, constants, or mock dependencies. The format is `--dart-define VARIABLE_NAME=VALUE`. For instance, `flutter test --dart-define MY_CONSTANT=5` sets a constant named `MY_CONSTANT` with the value `5`. These definitions are available only during testing and help ensure consistent test results.'
        dds-port: '[AI] `flutter test --dds-port` is a command used in Flutter development for running tests with Deterministic Docker Desktop (DDD). DDD is a feature that ensures consistent testing environments by creating isolated containers for each test run. The `--dds-port` option specifies the host port number where Docker listens for test results, facilitating communication between the Flutter application and the DDD service. This helps in maintaining a consistent testing environment across different development machines.'
        device-user: '[AI] The `--device-emulator` or `--device-chrome` option in Flutter''s `test` command is used to specify which emulator or Chrome tab to use when running tests. The `--device-user` flag, however, is not a standard Flutter CLI argument. It seems like there might be some confusion with the actual Flag usage here. The correct way to run tests in Flutter using an specific device or user profile is by setting up the test environment accordingly (for example, using Firebase Test Lab, Sauce Labs, or BrowserStack) and configuring your `flutter_tools` or `pubspec.yaml` file accordingly.'
        exclude-tags: '[AI] `flutter test --exclude-tags` is a command used in Flutter development for running tests with specific tags excluded. The `--exclude-tags` option allows specifying one or more tags to be omitted when selecting tests for execution. This can be useful when you want to run all tests except those marked with certain tags, for example, when you''re focused on fixing a specific issue and don''t want to be interrupted by other unrelated tests.'
        help: '[AI] `flutter test --help` is a command used in the Flutter framework to display help information about running tests using the Flutter Test runner. It provides a detailed explanation of available options and arguments for executing tests, including how to specify test filters, run tests in parallel or in a specific order, and configure test coverage reporting. This command is helpful for users who want to understand how to effectively use the Flutter Test runner to execute and manage their tests.'
        merge-coverage: '[AI] `flutter test --merge-coverage` is a command used in Flutter for generating merged test coverage reports. When running unit tests with Flutter, each test file generates its own coverage report. The `--merge-coverage` option merges these individual reports into a single comprehensive coverage report, providing a clearer overview of the overall code coverage across your entire test suite.'
        name: '[AI] `flutter test --name` is a command used in Flutter to run specific tests named with the given argument instead of running all tests. The `--name` option filters the tests based on their names and only runs those that match the provided argument. This can help save time by focusing on testing specific parts of your application.'
        no-null-assertions: '[AI] The `flutter test --no-null-assertions` command is used to run tests in a Flutter project without applying null safety checks. When you run your tests with this option, the Dart runtime will not throw an exception when encountering a potential null value, allowing the test to continue execution even if the code under test might contain nullable references that could cause issues with the null-safety checks enforced by Flutter. This is useful for testing legacy code or libraries that haven''t been migrated to null safety yet. However, be aware that running tests without null assertions might hide potential bugs related to handling null values and can lead to unexpected behavior in your application.'
        no-pub: '[AI] The `flutter test --no-pub` command is used to run tests in a Flutter project without using the `pub get` command to fetch dependencies first. This can be useful when you want to ensure that your local dependencies are being used, or if you want to skip the time it takes to download and install the dependencies each time you run the test suite. By passing the `--no-pub` flag, Flutter will bypass the dependency check and run the tests using only the locally available packages.'
        no-run-skipped: '[AI] The `flutter test --no-run-skipped` command is used to run all tests in a Flutter project but ignore any tests that have already passed without being re-executed. This can be useful for ensuring that all tests pass consistently across different runs or environments, as it prevents the skipped tests from artificially influencing the test results. By excluding the `--run-skipped` option, you ensure that only failed tests are retried and that previously passing tests are not accidentally re-executed.'
        no-test-assets: '[AI] `flutter test --no-test-assets` is a command used in Flutter development to run unit and widget tests without loading the test assets. This option is useful when the test assets are large or unnecessary for the test execution. By excluding the test assets, the test run time can be reduced and the build process can be made faster.'
        no-track-widget-creation: '[AI] The `flutter test` command is a Flutter CLI tool used to run tests in your Dart project. The `--no-track-widget-creation` option disables the creation of new widgets during testing. This flag can be useful when testing code that interacts with existing widgets in the application and does not want new widgets created during the test, as this could lead to unexpected behavior or test results that do not accurately reflect production usage. By disabling widget tracking, the tests will only use the widgets present in the application at the start of the test run.'
        null-assertions: |-
            [AI] The `flutter test --no-globals --nullable` or shorthand `flutter test --null-assertions` command is used to run tests in Dart without null safety checks. With this flag, the Dart analyzer will not enforce null safety rules during analysis, allowing null values to be assigned to non-nullable types and allowing the use of the '?' operator for nullable types without checking for nulls.

            This flag is useful when testing legacy code or third-party packages that may still use nullable types in Dart, as it allows the tests to run without encountering null safety errors. However, using this flag does increase the risk of null exceptions in production code and should be used with caution. It's recommended to transition your codebase to null safety as soon as possible for improved code reliability.
        plain-name: '[AI] `flutter test --plain-name` is a command used in Flutter for running tests with minimal output. The `--plain-name` option is passed to suppress the display of test class names in the test output, showing only the test name and result (pass or fail). This can be useful when dealing with large test suites where you''re more interested in the outcome than the structure of the tests.'
        pub: '[AI] The `flutter test --pub` command is used to run tests in a Flutter project with dependencies from pubspec.yaml updated. This means that it will fetch any new dependencies or updates to existing ones before running the tests. This helps ensure that the tests are run with the most current libraries and packages, reducing potential issues caused by outdated dependencies.'
        reporter: '[AI] `flutter test --reporter` is a command used in Flutter to execute unit tests and widget tests with a specific testing reporter. A testing reporter is a tool that formats and presents test results in different ways. By default, Flutter uses the "dots" reporter, which displays progress dots during test execution. However, you can use other reporters such as "json", "junit-xml", or "junit" to generate test reports in different formats for further analysis or integration with continuous integration tools.'
        run-skipped: '[AI] `flutter test --run-skipped` is a command used in Flutter, a mobile application development framework, to run only the failed or skipped tests in your test suite. When you execute this command, it will look for tests that have previously failed during the build process or were marked as "skipped" with the `expect` function''s `skip` argument in your test cases. This can help you focus on specific issues and ensure test coverage.'
        shard-index: |-
            [AI] The `flutter test --shard-index` command is used during testing in a Flutter project to manage the execution of tests across multiple cores or devices by dividing the tests into shards.

            The `--shard-index` option specifies the index of the current shard, which allows running multiple instances of tests concurrently. The tests are distributed evenly among the available shards for parallel processing, improving the overall testing speed and efficiency.

            This command is particularly useful when running large test suites on machines with multiple cores or when testing across different devices. By enabling parallel testing through sharding, developers can significantly reduce the time it takes to execute their tests.
        start-paused: '[AI] `flutter test --start-paused` is a command used in Flutter, a mobile app development framework, to run tests with the test harness paused at the first test case. This allows manual interaction or setup before automatically continuing the test execution. It''s useful when dealing with complex test scenarios or when you want to inspect the state of your application during testing.'
        tags: '[AI] `flutter test --tags` is a command used in Flutter for running tests with specific tags. Tests are labeled with tags to help organize and filter which ones to run. The `--tags` option allows specifying one or more tags as an argument to execute only those tests with matching tags. This helps in parallel testing, regression testing, or testing specific features without affecting others.'
        test-assets: '[AI] `flutter test --test-assets` is a command used in Flutter, a mobile application development framework. It runs tests with additional assets (e.g., images, sounds) required for test cases to execute properly. The assets are located in the `test/assets` directory and are bundled during the test run. This command enables comprehensive testing of applications that rely on dynamic assets.'
        test-randomize-ordering-seed: '[AI] The `flutter test` command with the option `--test-randomize-ordering-seed` is used to randomly order the tests within a Flutter project during test execution. This seed argument allows specifying a particular value to obtain consistent test ordering across different test runs, or to compare test results between different runs with the same seed value. If not provided, a default seed value is used and tests will be ordered differently each time the command is run.'
        timeout: '[AI] `flutter test --timeout` is a command-line option for the Flutter testing framework. It sets a time limit for individual tests to run. If a test takes longer than the specified timeout, it will be forcefully terminated and reported as failed. This can help prevent long-running tests from holding up the development workflow. The timeout value is usually given in milliseconds. For example, `--timeout 30000` sets a 30-second time limit for each test.'
        total-shards: '[AI] The `flutter test --total-shards` command is used to estimate the total number of testing isolates (called shards) required to run all tests in a Flutter project. This command provides an approximation to help with capacity planning for running tests, but the actual number may vary depending on the specific test execution environment and resource availability. The output will display the estimated number of shards along with a confidence level.'
        track-widget-creation: '[AI] `flutter test --track-widget-creation` is a command used during Flutter testing to enable tracking of widget creations for performance analysis. With this option, Flutter tests will log detailed information about each widget created during the test run, including the type of widget and the time taken for its creation. This data can be later analyzed using profiling tools like Flame or the Chrome DevTools Profiler to identify potential performance bottlenecks in the widget tree and optimize the testing and production code accordingly.'
        update-goldens: '[AI] `flutter test --update-goldens` is a command used in Flutter development to update golden files during tests. Golden files are image or widget snapshots that are saved and compared against during testing to ensure visual regression. Running this command updates the golden files with current test output, allowing for continued comparison of test results to previous renders and identifying any potential visual changes.'
        web-renderer: '[AI] `flutter test --web-renderer` is a command used in Flutter development to run unit tests and widget tests in web mode using the WebTestRunner. This command launches a Chrome or Chromium browser instance, loads the test files from the project, and runs them in an isolated environment. The output is displayed in the terminal, and any assertion failures will cause the test to fail and provide an error message. It''s useful for testing Flutter applications that are targeted for web deployment.'
