# yaml-language-server: $schema=https://carapace.sh/schemas/command.json
name: replace -f FILENAME
description: Replace a resource by file name or stdin
group: advanced
flags:
    --allow-missing-template-keys: If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
    --cascade?: Must be "background", "orphan", or "foreground". Selects the deletion cascading strategy for the dependents (e.g. Pods created by a ReplicationController). Defaults to background.
    --dry-run?: Must be "none", "server", or "client". If client strategy, only print the object that would be sent, without sending it. If server strategy, submit server-side request without persisting the resource.
    --field-manager=: Name of the manager used to track field ownership.
    --force: If true, immediately remove resources from API and bypass graceful deletion. Note that immediate deletion of some resources may result in inconsistency or data loss and requires confirmation.
    --grace-period=: Period of time in seconds given to the resource to terminate gracefully. Ignored if negative. Set to 1 for immediate shutdown. Can only be set to 0 when --force is true (force deletion).
    --raw=: Raw URI to PUT to the server.  Uses the transport specified by the kubeconfig file.
    --save-config: If true, the configuration of current object will be saved in its annotation. Otherwise, the annotation will be unchanged. This flag is useful when you want to perform kubectl apply on this object in the future.
    --show-managed-fields: If true, keep the managedFields when printing objects in JSON or YAML format.
    --subresource=: If specified, replace will operate on the subresource of the requested object. Must be one of [status scale]. This flag is beta and may change in the future.
    --template=: Template string or path to template file to use when -o=go-template, -o=go-template-file. The template format is golang templates [http://golang.org/pkg/text/template/#pkg-overview].
    --timeout=: The length of time to wait before giving up on a delete, zero means determine a timeout from the size of the object
    --validate?: Validation mode.
    --wait: If true, wait for resources to be gone before returning. This waits for finalizers.
    -R, --recursive: Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.
    -f, --filename*=: The files that contain the configurations to replace.
    -k, --kustomize=: Process a kustomization directory. This flag can't be used together with -f or -R.
    -o, --output=: 'Output format. One of: (json, yaml, name, go-template, go-template-file, template, templatefile, jsonpath, jsonpath-as-json, jsonpath-file).'
documentation:
    command: '[AI] `kubectl replace` is a command used in Kubernetes to update the configuration of existing resources, such as deployments, services, or config maps. It retrieves the current resource definition from the cluster and allows you to modify it before applying the changes back to the cluster. This is particularly useful when you want to make small adjustments to a resource''s YAML manifest without having to delete and recreate the entire resource. The updated resource will have the same name, namespace, and UID as the original one, ensuring minimal disruption to the running applications.'
    flag:
        allow-missing-template-keys: '[AI] `kubectl replace --allow-missing-template-keys` is a command used in Kubernetes to update the definition of a resource with a YAML file, while ignoring missing keys in the new file that do not exist in the existing resource. This flag is particularly useful when incrementally updating a complex YAML file without modifying all the keys at once, as it avoids errors due to missing keys and automatically creates new ones if they are defined in the new file. It''s important to note that this flag may create or modify the configuration of other resources referenced in the file as well.'
        cascade: '[AI] `kubectl replace --cascade` is a command used in Kubernetes to update resources by replacing existing objects with new ones while preserving their history and cascading the changes to related objects. This means that if you modify a resource, Kubernetes will automatically apply the same changes to its dependent resources, maintaining the desired state across the entire cluster. It''s particularly useful when making updates to configurations where multiple objects are interconnected.'
        dry-run: '[AI] `kubectl replace --dry-run` is a command used in Kubernetes to test the effects of modifying resources before actually making the changes. The `replace` action updates an existing resource by creating a new version with the specified modifications, while the `--dry-run` flag instructs `kubectl` to output the YAML manifest describing the proposed changes without applying them to the cluster. This can be useful for reviewing and validating modifications before executing them in a production environment.'
        field-manager: '[AI] `kubectl replace --field-manager` is a command used in Kubernetes to update the configuration of existing resources while preserving their history and metadata. The `--field-manager` flag specifies that the update should be performed using the Declarative Admission Controller, which ensures that the desired state of the resource is consistently maintained over time. This flag provides a more declarative way to manage Kubernetes objects and helps ensure consistency across clusters or environments.'
        filename: '[AI] `kubectl replace --filename` is a command used in Kubernetes to update the configuration of existing resources, such as deployments or services, by applying the changes from a YAML file. The `--filename` flag specifies the path to the YAML file that contains the new configuration. This command does not create a new resource if it doesn''t exist; instead, it modifies the existing one with the specified changes. If no resources match the given label selector, then nothing will be modified. The `kubectl` tool connects to the Kubernetes cluster and sends the replace request to the API server for processing.'
        force: '[AI] `kubectl replace --force` is a command used with Kubernetes'' `kubectl` tool to update existing resources in a cluster with new configurations. The `--force` flag signifies that any conflicts during the update will be resolved by overwriting the existing resource without user intervention. It''s important to use this flag with caution, as it can result in data loss if used on resources containing critical information.'
        grace-period: '[AI] `kubectl replace` is a command used to update existing Kubernetes resources, such as Deployments or Services. The `--grace-period` flag sets the length of time (in seconds) after which Kubernetes will forcefully terminate instances of the updated resource that fail to converge with the new specification. This provides a safety net for users by allowing them to roll back to the previous version if necessary, before the old instances are completely terminated. The default grace period is 30 seconds.'
        kustomize: |-
            [AI] `kubectl replace --kustomize` is a command used with the Kubernetes command-line interface (CLI) tool `kubectl`. This command is used to update the configuration of existing Kubernetes resources by applying customized changes using Kustomize.

            Kustomize is a configuration management system for Kubernetes that allows managing and deploying applications through declarative extensions. It uses YAML files with customizations, named patches or differences, to modify the original resource manifests.

            `kubectl replace --kustomize` takes a path to a directory containing one or more Kustomize-managed YAML files as an argument. This command then updates the resources in the cluster by replacing them with the updated versions specified in the Kustomize patches without requiring manual creation or deletion of the custom resources. The changes are merged with the current state and persisted in the cluster.
        output: '[AI] `kubectl replace` is a command used to update existing resources in a Kubernetes cluster. The `--output` flag determines the output format for the command''s response. It can be set to `json`, `yaml`, or `none`. When `--output=json` or `--output=yaml` is specified, the command will output the updated resource in the corresponding format instead of printing it to the console by default. With `--output=none`, no output will be shown and only the status code and message will be displayed.'
        raw: '[AI] `kubectl replace --raw` is a command used with the Kubernetes command-line tool (kubectl) to update the definition of a Kubernetes resource, such as a Deployment or a ConfigMap, by providing the new configuration directly in YAML format through its standard input (STDIN). The `--raw` flag disables automatic escaping of special characters in the input. This can be useful when you want to pass complex configurations with YAML constructs like anchors, aliases, or templates without worrying about the need for special escaping. By piping a new YAML configuration into `kubectl replace`, you can update existing resources in your cluster while maintaining version control and auditability via the Kubernetes API.'
        recursive: '[AI] `kubectl replace --recursive` is a command-line utility used in Kubernetes to update resources and their nested dependencies in a cluster. With this command, you can modify a specific resource and its related resources that depend on it, ensuring they are all updated in a consistent state. For instance, if you have a Deployment managing a ReplicaSet, and you want to change the image tag of the container in the Deployment, running `kubectl replace --recursive -f <deployment-file.yaml>` will update both the Deployment file as well as the ReplicaSet file if needed. It''s useful for applying changes across multiple interconnected resources within a Kubernetes cluster while maintaining consistency.'
        save-config: '[AI] `kubectl replace --save-config` is a command used in Kubernetes to update the definition of a resource (such as a deployment, service, or config map) while saving the new configuration back to the local `kubeconfig` file. This means that after making changes using this command, those modifications will persist across `kubectl` sessions. The flag ensures that the updated configuration is stored locally, allowing for consistent application of the changes in future commands.'
        show-managed-fields: '[AI] `kubectl replace --show-managed-fields` is a command used with the Kubernetes command-line interface (CLI) tool, `kubectl`. This command is used to update the configuration of existing Kubernetes resources, such as deployments or services, while displaying the managed fields that were changed in the new version of the resource. The `--show-managed-fields` flag ensures that the output includes a list of the specific fields within the resource that have been modified during the replacement operation. This information can be useful for understanding exactly what changes were made to the resource, and when used alongside version control tools, can facilitate tracking and managing updates to Kubernetes resources.'
        subresource: '[AI] `kubectl replace --subresource` is a command used with the Kubernetes `kubectl` tool to update specific fields of custom resources or built-in resources, without changing the entire resource object. This command allows for partial updates by targeting a specific subresource under the main resource. For example, if you have a Deployment with multiple replicas and want to modify just one label, use `kubectl replace --subresource=label <resource-kind>/<resource-name> -f <file-with-patch>`. This will update only the specified subresource without affecting others.'
        template: '[AI] `kubectl replace --template` is a command used with Kubernetes'' `kubectl` tool to update the definition of existing Kubernetes resources based on a given template file. The command retrieves the current resource configuration, applies the specified template modifications, and then replaces the resource in the cluster with the updated configuration. It allows for dynamic updates, as the new definition can include expressions that reference the current state of the resource or other resources. This is particularly useful when making complex changes to YAML manifests without having to manually update every field.'
        timeout: '[AI] `kubectl replace` is a command-line tool used for managing resources in Kubernetes clusters. The `--timeout` flag sets the duration for which `kubectl` waits for the replacement process to complete before returning control back to the user. It accepts values in seconds or duration strings (e.g., "3m" for 3 minutes). If the replacement fails, `kubectl` will continue retrying based on the built-in retry mechanism until the defined timeout is reached.'
        validate: '[AI] `kubectl replace --validate` is a command used with the Kubernetes command-line interface (CLI) tool, `kubectl`. This command is used to update existing Kubernetes resources in a cluster by creating a new version of the resource from a YAML file or from stdin, and then performing validation checks against the current state of the cluster before applying the changes. The `--validate` flag ensures that the proposed changes are valid according to the Kubernetes schema and do not contain any syntax errors, but it does not actually apply the changes to the cluster. If no errors are found, you can use `kubectl apply` to apply the updated resource to the cluster.'
        wait: '[AI] `kubectl replace --wait` is a command used in Kubernetes to update the configuration of a resource, such as a Deployment or Service, by applying a new YAML file while ensuring that the old resource is fully replaced before applying the new one. The `--wait` flag ensures that `kubectl` waits until the new resource is fully updated and available before returning control to the user. This can be useful for ensuring consistency and avoiding potential conflicts or errors in complex deployments.'
